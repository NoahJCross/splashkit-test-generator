{
  "functions": [
    {
      "signature": "bool bitmap_circle_collision(bitmap bmp,const point_2d& pt,const circle& circ);",
      "name": "bitmap_circle_collision",
      "method_name": "circle_collision",
      "unique_global_name": "bitmap_circle_collision_at_point",
      "unique_method_name": "bitmap.circle_collision_at_point",
      "suffix_name": null,
      "description": "Tests if a bitmap drawn at `pt` would intersect with a circle.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if a drawn pixel in the cell of the bitmap will\nintersect with `circ` when drawn.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "bmp": {
          "type": "bitmap",
          "description": "The bitmap to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "pt": {
          "type": "point_2d",
          "description": "The location where the bitmap is drawn",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "circ": {
          "type": "circle",
          "description": "The circle to test",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "bitmap",
        "method": "circle_collision",
        "suffix": "at_point",
        "group": "physics",
        "static": "collisions",
        "self": "bmp"
      },
      "signatures": {
        "cpp": [
          "bool bitmap_circle_collision(bitmap bmp, const point_2d &pt, const circle &circ)"
        ],
        "rust": [
          "pub fn bitmap_circle_collision(bmp: bitmap, pt: &point_2d, circ: &circle) -> bool"
        ],
        "python": [
          "def bitmap_circle_collision_at_point(bmp, pt, circ):"
        ],
        "pascal": [
          "function BitmapCircleCollision(bmp: Bitmap; const pt: Point2D; const circ: Circle): Boolean"
        ],
        "csharp": [
          "public bool Bitmap.BitmapCircleCollision(Point2D pt, Circle circ);",
          "public static bool SplashKit.BitmapCircleCollision(Bitmap bmp, Point2D pt, Circle circ);"
        ]
      }
    },
    {
      "signature": "bool bitmap_circle_collision(bitmap bmp,double x,double y,const circle& circ);",
      "name": "bitmap_circle_collision",
      "method_name": "circle_collision",
      "unique_global_name": "bitmap_circle_collision",
      "unique_method_name": "bitmap.circle_collision",
      "suffix_name": null,
      "description": "Tests if a bitmap drawn at `x`, `y` would intersect with a circle.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if a drawn pixel in the bitmap will\nintersect with `circ` when drawn.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "bmp": {
          "type": "bitmap",
          "description": "The bitmap to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "x": {
          "type": "double",
          "description": "The x location where the bitmap is drawn",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "y": {
          "type": "double",
          "description": "The y location where the bitmap is drawn",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "circ": {
          "type": "circle",
          "description": "The circle to test",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "bitmap",
        "method": "circle_collision",
        "group": "physics",
        "static": "collisions",
        "self": "bmp"
      },
      "signatures": {
        "cpp": [
          "bool bitmap_circle_collision(bitmap bmp, double x, double y, const circle &circ)"
        ],
        "rust": [
          "pub fn bitmap_circle_collision(bmp: bitmap, x: f64, y: f64, circ: &circle) -> bool"
        ],
        "python": [
          "def bitmap_circle_collision(bmp, x, y, circ):"
        ],
        "pascal": [
          "function BitmapCircleCollision(bmp: Bitmap; x: Double; y: Double; const circ: Circle): Boolean"
        ],
        "csharp": [
          "public bool Bitmap.BitmapCircleCollision(double x, double y, Circle circ);",
          "public static bool SplashKit.BitmapCircleCollision(Bitmap bmp, double x, double y, Circle circ);"
        ]
      }
    },
    {
      "signature": "bool bitmap_circle_collision(bitmap bmp,int cell,const matrix_2d& translation,const circle& circ);",
      "name": "bitmap_circle_collision",
      "method_name": "circle_collision",
      "unique_global_name": "bitmap_circle_collision_for_cell_with_translation",
      "unique_method_name": "bitmap.circle_collision_for_cell_with_translation",
      "suffix_name": null,
      "description": "Tests if a bitmap cell drawn using a passed in translation, will\nintersect with a circle. You can use this to detect collisions between\nbitmaps and circles.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if a drawn pixel in the cell of the bitmap will\nintersect with `circ` when drawn.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "bmp": {
          "type": "bitmap",
          "description": "The bitmap to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "cell": {
          "type": "int",
          "description": "The cell of the bitmap to check",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "translation": {
          "type": "matrix_2d",
          "description": "The matrix used to transfrom the bitmap when drawing",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "circ": {
          "type": "circle",
          "description": "The circle to test",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "bitmap",
        "method": "circle_collision",
        "suffix": "for_cell_with_translation",
        "group": "physics",
        "static": "collisions",
        "self": "bmp"
      },
      "signatures": {
        "cpp": [
          "bool bitmap_circle_collision(bitmap bmp, int cell, const matrix_2d &translation, const circle &circ)"
        ],
        "rust": [
          "pub fn bitmap_circle_collision(bmp: bitmap, cell: i32, translation: &matrix_2d, circ: &circle) -> bool"
        ],
        "python": [
          "def bitmap_circle_collision_for_cell_with_translation(bmp, cell, translation, circ):"
        ],
        "pascal": [
          "function BitmapCircleCollision(bmp: Bitmap; cell: Integer; const translation: Matrix2D; const circ: Circle): Boolean"
        ],
        "csharp": [
          "public bool Bitmap.BitmapCircleCollision(int cell, Matrix2D translation, Circle circ);",
          "public static bool SplashKit.BitmapCircleCollision(Bitmap bmp, int cell, Matrix2D translation, Circle circ);"
        ]
      }
    },
    {
      "signature": "bool bitmap_circle_collision(bitmap bmp,int cell,const point_2d& pt,const circle& circ);",
      "name": "bitmap_circle_collision",
      "method_name": "circle_collision",
      "unique_global_name": "bitmap_circle_collision_for_cell_at_point",
      "unique_method_name": "bitmap.circle_collision_for_cell_at_point",
      "suffix_name": null,
      "description": "Tests if a bitmap cell drawn at `pt` would intersect with a circle.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if a drawn pixel in the cell of the bitmap will\nintersect with `circ` when drawn.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "bmp": {
          "type": "bitmap",
          "description": "The bitmap to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "cell": {
          "type": "int",
          "description": "The cell of the bitmap to check",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "pt": {
          "type": "point_2d",
          "description": "The location where the bitmap is drawn",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "circ": {
          "type": "circle",
          "description": "The circle to test",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "bitmap",
        "method": "circle_collision",
        "suffix": "for_cell_at_point",
        "group": "physics",
        "static": "collisions",
        "self": "bmp"
      },
      "signatures": {
        "cpp": [
          "bool bitmap_circle_collision(bitmap bmp, int cell, const point_2d &pt, const circle &circ)"
        ],
        "rust": [
          "pub fn bitmap_circle_collision(bmp: bitmap, cell: i32, pt: &point_2d, circ: &circle) -> bool"
        ],
        "python": [
          "def bitmap_circle_collision_for_cell_at_point(bmp, cell, pt, circ):"
        ],
        "pascal": [
          "function BitmapCircleCollision(bmp: Bitmap; cell: Integer; const pt: Point2D; const circ: Circle): Boolean"
        ],
        "csharp": [
          "public bool Bitmap.BitmapCircleCollision(int cell, Point2D pt, Circle circ);",
          "public static bool SplashKit.BitmapCircleCollision(Bitmap bmp, int cell, Point2D pt, Circle circ);"
        ]
      }
    },
    {
      "signature": "bool bitmap_circle_collision(bitmap bmp,int cell,double x,double y,const circle& circ);",
      "name": "bitmap_circle_collision",
      "method_name": "circle_collision",
      "unique_global_name": "bitmap_circle_collision_for_cell",
      "unique_method_name": "bitmap.circle_collision_for_cell",
      "suffix_name": null,
      "description": "Tests if a bitmap cell drawn at `x`, `y` would intersect with a circle.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if a drawn pixel in the bitmap will\nintersect with `circ` when drawn.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "bmp": {
          "type": "bitmap",
          "description": "The bitmap to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "cell": {
          "type": "int",
          "description": "The cell of the bitmap to check",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "x": {
          "type": "double",
          "description": "The x location where the bitmap is drawn",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "y": {
          "type": "double",
          "description": "The y location where the bitmap is drawn",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "circ": {
          "type": "circle",
          "description": "The circle to test",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "bitmap",
        "method": "circle_collision",
        "suffix": "for_cell",
        "group": "physics",
        "static": "collisions",
        "self": "bmp"
      },
      "signatures": {
        "cpp": [
          "bool bitmap_circle_collision(bitmap bmp, int cell, double x, double y, const circle &circ)"
        ],
        "rust": [
          "pub fn bitmap_circle_collision(bmp: bitmap, cell: i32, x: f64, y: f64, circ: &circle) -> bool"
        ],
        "python": [
          "def bitmap_circle_collision_for_cell(bmp, cell, x, y, circ):"
        ],
        "pascal": [
          "function BitmapCircleCollision(bmp: Bitmap; cell: Integer; x: Double; y: Double; const circ: Circle): Boolean"
        ],
        "csharp": [
          "public bool Bitmap.BitmapCircleCollision(int cell, double x, double y, Circle circ);",
          "public static bool SplashKit.BitmapCircleCollision(Bitmap bmp, int cell, double x, double y, Circle circ);"
        ]
      }
    },
    {
      "signature": "bool bitmap_collision(bitmap bmp1,double x1,double y1,bitmap bmp2,double x2,double y2);",
      "name": "bitmap_collision",
      "method_name": "bitmap_collision",
      "unique_global_name": "bitmap_collision",
      "unique_method_name": "bitmap.bitmap_collision",
      "suffix_name": null,
      "description": "Check if two bitmaps collide.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if pixels in the two bitmaps would collide/overlap",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "bmp1": {
          "type": "bitmap",
          "description": "The first bitmap",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "x1": {
          "type": "double",
          "description": "The x location where the first bitmap is drawn",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "y1": {
          "type": "double",
          "description": "The y location where the first bitmap is drawn",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "bmp2": {
          "type": "bitmap",
          "description": "The second bitmap",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "x2": {
          "type": "double",
          "description": "The x location where the second bitmap is drawn",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "y2": {
          "type": "double",
          "description": "The y location where the second bitmap is drawn",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "bitmap",
        "method": "bitmap_collision",
        "group": "physics",
        "static": "collisions",
        "self": "bmp1"
      },
      "signatures": {
        "cpp": [
          "bool bitmap_collision(bitmap bmp1, double x1, double y1, bitmap bmp2, double x2, double y2)"
        ],
        "rust": [
          "pub fn bitmap_collision(bmp1: bitmap, x1: f64, y1: f64, bmp2: bitmap, x2: f64, y2: f64) -> bool"
        ],
        "python": [
          "def bitmap_collision(bmp1, x1, y1, bmp2, x2, y2):"
        ],
        "pascal": [
          "function BitmapCollision(bmp1: Bitmap; x1: Double; y1: Double; bmp2: Bitmap; x2: Double; y2: Double): Boolean"
        ],
        "csharp": [
          "public bool Bitmap.BitmapCollision(double x1, double y1, Bitmap bmp2, double x2, double y2);",
          "public static bool SplashKit.BitmapCollision(Bitmap bmp1, double x1, double y1, Bitmap bmp2, double x2, double y2);"
        ]
      }
    },
    {
      "signature": "bool bitmap_collision(bitmap bmp1,const point_2d &pt1,bitmap bmp2,const point_2d &pt2);",
      "name": "bitmap_collision",
      "method_name": "bitmap_collision",
      "unique_global_name": "bitmap_collision_at_points",
      "unique_method_name": "bitmap.bitmap_collision_at_points",
      "suffix_name": null,
      "description": "Check if two bitmaps collide.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if pixels in the two bitmaps would collide/overlap",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "bmp1": {
          "type": "bitmap",
          "description": "The first bitmap",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "pt1": {
          "type": "point_2d",
          "description": "The point where bitmap 1 is drawn",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "bmp2": {
          "type": "bitmap",
          "description": "The second bitmap",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "pt2": {
          "type": "point_2d",
          "description": "The point where bitmap 2 is drawn",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "bitmap",
        "method": "bitmap_collision",
        "suffix": "at_points",
        "group": "physics",
        "static": "collisions",
        "self": "bmp1"
      },
      "signatures": {
        "cpp": [
          "bool bitmap_collision(bitmap bmp1, const point_2d &pt1, bitmap bmp2, const point_2d &pt2)"
        ],
        "rust": [
          "pub fn bitmap_collision(bmp1: bitmap, pt1: &point_2d, bmp2: bitmap, pt2: &point_2d) -> bool"
        ],
        "python": [
          "def bitmap_collision_at_points(bmp1, pt1, bmp2, pt2):"
        ],
        "pascal": [
          "function BitmapCollision(bmp1: Bitmap; const pt1: Point2D; bmp2: Bitmap; const pt2: Point2D): Boolean"
        ],
        "csharp": [
          "public bool Bitmap.BitmapCollision(Point2D pt1, Bitmap bmp2, Point2D pt2);",
          "public static bool SplashKit.BitmapCollision(Bitmap bmp1, Point2D pt1, Bitmap bmp2, Point2D pt2);"
        ]
      }
    },
    {
      "signature": "bool bitmap_collision(bitmap bmp1,int cell1,const matrix_2d &matrix1,bitmap bmp2,int cell2,const matrix_2d &matrix2);",
      "name": "bitmap_collision",
      "method_name": "bitmap_collision",
      "unique_global_name": "bitmap_collision_for_cells_with_translations",
      "unique_method_name": "bitmap.bitmap_collision_for_cells_with_translations",
      "suffix_name": null,
      "description": "Check if two bitmaps collide, based on their cell and transform\nmatricies.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if pixels in the two bitmaps would collide/overlap",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "bmp1": {
          "type": "bitmap",
          "description": "The first bitmap",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "cell1": {
          "type": "int",
          "description": "The cell of the first bitmap.",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "matrix1": {
          "type": "matrix_2d",
          "description": "The transformation for the first matrix",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "bmp2": {
          "type": "bitmap",
          "description": "The second bitmap",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "cell2": {
          "type": "int",
          "description": "The cell of the second bitmap.",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "matrix2": {
          "type": "matrix_2d",
          "description": "The transformation for the second matrix",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "bitmap",
        "method": "bitmap_collision",
        "suffix": "for_cells_with_translations",
        "group": "physics",
        "static": "collisions",
        "self": "bmp1"
      },
      "signatures": {
        "cpp": [
          "bool bitmap_collision(bitmap bmp1, int cell1, const matrix_2d &matrix1, bitmap bmp2, int cell2, const matrix_2d &matrix2)"
        ],
        "rust": [
          "pub fn bitmap_collision(bmp1: bitmap, cell1: i32, matrix1: &matrix_2d, bmp2: bitmap, cell2: i32, matrix2: &matrix_2d) -> bool"
        ],
        "python": [
          "def bitmap_collision_for_cells_with_translations(bmp1, cell1, matrix1, bmp2, cell2, matrix2):"
        ],
        "pascal": [
          "function BitmapCollision(bmp1: Bitmap; cell1: Integer; const matrix1: Matrix2D; bmp2: Bitmap; cell2: Integer; const matrix2: Matrix2D): Boolean"
        ],
        "csharp": [
          "public bool Bitmap.BitmapCollision(int cell1, Matrix2D matrix1, Bitmap bmp2, int cell2, Matrix2D matrix2);",
          "public static bool SplashKit.BitmapCollision(Bitmap bmp1, int cell1, Matrix2D matrix1, Bitmap bmp2, int cell2, Matrix2D matrix2);"
        ]
      }
    },
    {
      "signature": "bool bitmap_collision(bitmap bmp1,int cell1,const point_2d &pt1,bitmap bmp2,int cell2,const point_2d &pt2);",
      "name": "bitmap_collision",
      "method_name": "bitmap_collision",
      "unique_global_name": "bitmap_collision_for_cells_at_points",
      "unique_method_name": "bitmap.bitmap_collision_for_cells_at_points",
      "suffix_name": null,
      "description": "Check if two bitmaps collide.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if pixels in the two bitmaps would collide/overlap",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "bmp1": {
          "type": "bitmap",
          "description": "The first bitmap",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "cell1": {
          "type": "int",
          "description": "The cell of the first bitmap.",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "pt1": {
          "type": "point_2d",
          "description": "The point where bitmap 1 is drawn",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "bmp2": {
          "type": "bitmap",
          "description": "The second bitmap",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "cell2": {
          "type": "int",
          "description": "The cell of the second bitmap.",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "pt2": {
          "type": "point_2d",
          "description": "The point where bitmap 2 is drawn",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "bitmap",
        "method": "bitmap_collision",
        "suffix": "for_cells_at_points",
        "group": "physics",
        "static": "collisions",
        "self": "bmp1"
      },
      "signatures": {
        "cpp": [
          "bool bitmap_collision(bitmap bmp1, int cell1, const point_2d &pt1, bitmap bmp2, int cell2, const point_2d &pt2)"
        ],
        "rust": [
          "pub fn bitmap_collision(bmp1: bitmap, cell1: i32, pt1: &point_2d, bmp2: bitmap, cell2: i32, pt2: &point_2d) -> bool"
        ],
        "python": [
          "def bitmap_collision_for_cells_at_points(bmp1, cell1, pt1, bmp2, cell2, pt2):"
        ],
        "pascal": [
          "function BitmapCollision(bmp1: Bitmap; cell1: Integer; const pt1: Point2D; bmp2: Bitmap; cell2: Integer; const pt2: Point2D): Boolean"
        ],
        "csharp": [
          "public bool Bitmap.BitmapCollision(int cell1, Point2D pt1, Bitmap bmp2, int cell2, Point2D pt2);",
          "public static bool SplashKit.BitmapCollision(Bitmap bmp1, int cell1, Point2D pt1, Bitmap bmp2, int cell2, Point2D pt2);"
        ]
      }
    },
    {
      "signature": "bool bitmap_collision(bitmap bmp1,int cell1,double x1,double y1,bitmap bmp2,int cell2,double x2,double y2);",
      "name": "bitmap_collision",
      "method_name": "bitmap_collision",
      "unique_global_name": "bitmap_collision_for_cells",
      "unique_method_name": "bitmap.bitmap_collision_for_cells",
      "suffix_name": null,
      "description": "Check if two bitmaps collide.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if pixels in the two bitmaps would collide/overlap",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "bmp1": {
          "type": "bitmap",
          "description": "The first bitmap",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "cell1": {
          "type": "int",
          "description": "The cell of the first bitmap.",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "x1": {
          "type": "double",
          "description": "The x location where the first bitmap is drawn",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "y1": {
          "type": "double",
          "description": "The y location where the first bitmap is drawn",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "bmp2": {
          "type": "bitmap",
          "description": "The second bitmap",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "cell2": {
          "type": "int",
          "description": "The cell of the second bitmap.",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "x2": {
          "type": "double",
          "description": "The x location where the second bitmap is drawn",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "y2": {
          "type": "double",
          "description": "The y location where the second bitmap is drawn",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "bitmap",
        "method": "bitmap_collision",
        "suffix": "for_cells",
        "group": "physics",
        "static": "collisions",
        "self": "bmp1"
      },
      "signatures": {
        "cpp": [
          "bool bitmap_collision(bitmap bmp1, int cell1, double x1, double y1, bitmap bmp2, int cell2, double x2, double y2)"
        ],
        "rust": [
          "pub fn bitmap_collision(bmp1: bitmap, cell1: i32, x1: f64, y1: f64, bmp2: bitmap, cell2: i32, x2: f64, y2: f64) -> bool"
        ],
        "python": [
          "def bitmap_collision_for_cells(bmp1, cell1, x1, y1, bmp2, cell2, x2, y2):"
        ],
        "pascal": [
          "function BitmapCollision(bmp1: Bitmap; cell1: Integer; x1: Double; y1: Double; bmp2: Bitmap; cell2: Integer; x2: Double; y2: Double): Boolean"
        ],
        "csharp": [
          "public bool Bitmap.BitmapCollision(int cell1, double x1, double y1, Bitmap bmp2, int cell2, double x2, double y2);",
          "public static bool SplashKit.BitmapCollision(Bitmap bmp1, int cell1, double x1, double y1, Bitmap bmp2, int cell2, double x2, double y2);"
        ]
      }
    },
    {
      "signature": "bool bitmap_point_collision(bitmap bmp,const matrix_2d& translation,const point_2d& pt);",
      "name": "bitmap_point_collision",
      "method_name": "point_collision",
      "unique_global_name": "bitmap_point_collision_with_translation",
      "unique_method_name": "bitmap.point_collision_with_translation",
      "suffix_name": null,
      "description": "Tests if a bitmap drawn using the passed in translation matrix would draw a pixel\nat the passed in point. Use to check collisions between a point and a bitmap.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if drawing the bitmap, using the passed in translation,\nwill draw a pixel at the indicated point.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "bmp": {
          "type": "bitmap",
          "description": "The bitmap to test.",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "translation": {
          "type": "matrix_2d",
          "description": "The translation matrix that represents the position, scale,\nand rotation of the bitmap when it is drawn.",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "pt": {
          "type": "point_2d",
          "description": "The point in the resulting drawing that is being tested.",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "bitmap",
        "method": "point_collision",
        "suffix": "with_translation",
        "group": "physics",
        "static": "collisions",
        "self": "bmp"
      },
      "signatures": {
        "cpp": [
          "bool bitmap_point_collision(bitmap bmp, const matrix_2d &translation, const point_2d &pt)"
        ],
        "rust": [
          "pub fn bitmap_point_collision(bmp: bitmap, translation: &matrix_2d, pt: &point_2d) -> bool"
        ],
        "python": [
          "def bitmap_point_collision_with_translation(bmp, translation, pt):"
        ],
        "pascal": [
          "function BitmapPointCollision(bmp: Bitmap; const translation: Matrix2D; const pt: Point2D): Boolean"
        ],
        "csharp": [
          "public bool Bitmap.BitmapPointCollision(Matrix2D translation, Point2D pt);",
          "public static bool SplashKit.BitmapPointCollision(Bitmap bmp, Matrix2D translation, Point2D pt);"
        ]
      }
    },
    {
      "signature": "bool bitmap_point_collision(bitmap bmp,const point_2d &bmp_pt,const point_2d& pt);",
      "name": "bitmap_point_collision",
      "method_name": "point_collision",
      "unique_global_name": "bitmap_point_collision_at_point",
      "unique_method_name": "bitmap.point_collision_at_point",
      "suffix_name": null,
      "description": "Tests if a bitmap drawn at the `bmp_pt` point would draw a pixel\nat point `pt`. Use to check collisions between a point and a bitmap.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if drawing the bitmap, at `bmp_pt`,\nwill draw a pixel at the indicated point (`pt`).",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "bmp": {
          "type": "bitmap",
          "description": "The bitmap to test.",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "bmp_pt": {
          "type": "point_2d",
          "description": "The point where the bitmap is drawn.",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "pt": {
          "type": "point_2d",
          "description": "The point in the resulting drawing that is being tested.",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "bitmap",
        "method": "point_collision",
        "suffix": "at_point",
        "group": "physics",
        "static": "collisions",
        "self": "bmp"
      },
      "signatures": {
        "cpp": [
          "bool bitmap_point_collision(bitmap bmp, const point_2d &bmp_pt, const point_2d &pt)"
        ],
        "rust": [
          "pub fn bitmap_point_collision(bmp: bitmap, bmp_pt: &point_2d, pt: &point_2d) -> bool"
        ],
        "python": [
          "def bitmap_point_collision_at_point(bmp, bmp_pt, pt):"
        ],
        "pascal": [
          "function BitmapPointCollision(bmp: Bitmap; const bmpPt: Point2D; const pt: Point2D): Boolean"
        ],
        "csharp": [
          "public bool Bitmap.BitmapPointCollision(Point2D bmpPt, Point2D pt);",
          "public static bool SplashKit.BitmapPointCollision(Bitmap bmp, Point2D bmpPt, Point2D pt);"
        ]
      }
    },
    {
      "signature": "bool bitmap_point_collision(bitmap bmp,double bmp_x,double bmp_y,double x,double y);",
      "name": "bitmap_point_collision",
      "method_name": "point_collision",
      "unique_global_name": "bitmap_point_collision",
      "unique_method_name": "bitmap.point_collision",
      "suffix_name": null,
      "description": "Tests if a bitmap drawn at x,y would draw a pixel at the passed in point. Use \nto check collisions between a point and a bitmap.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if drawing the bitmap, at the indicated location,\nwill draw a pixel at the indicated point.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "bmp": {
          "type": "bitmap",
          "description": "The bitmap to test.",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "bmp_x": {
          "type": "double",
          "description": "The x location where the bitmap is drawn",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "bmp_y": {
          "type": "double",
          "description": "The y location where the bitmap is drawn",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "x": {
          "type": "double",
          "description": "The x location of the point to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "y": {
          "type": "double",
          "description": "The y location of the point to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "bitmap",
        "method": "point_collision",
        "group": "physics",
        "static": "collisions",
        "self": "bmp"
      },
      "signatures": {
        "cpp": [
          "bool bitmap_point_collision(bitmap bmp, double bmp_x, double bmp_y, double x, double y)"
        ],
        "rust": [
          "pub fn bitmap_point_collision(bmp: bitmap, bmp_x: f64, bmp_y: f64, x: f64, y: f64) -> bool"
        ],
        "python": [
          "def bitmap_point_collision(bmp, bmp_x, bmp_y, x, y):"
        ],
        "pascal": [
          "function BitmapPointCollision(bmp: Bitmap; bmpX: Double; bmpY: Double; x: Double; y: Double): Boolean"
        ],
        "csharp": [
          "public bool Bitmap.BitmapPointCollision(double bmpX, double bmpY, double x, double y);",
          "public static bool SplashKit.BitmapPointCollision(Bitmap bmp, double bmpX, double bmpY, double x, double y);"
        ]
      }
    },
    {
      "signature": "bool bitmap_point_collision(bitmap bmp,int cell,const matrix_2d& translation,const point_2d& pt);",
      "name": "bitmap_point_collision",
      "method_name": "point_collision",
      "unique_global_name": "bitmap_point_collision_for_cell_with_translation",
      "unique_method_name": "bitmap.point_collision_for_cell_with_translation",
      "suffix_name": null,
      "description": "Tests if a bitmap cell drawn using the passed in translation matrix would draw a pixel\nat the passed in point.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if drawing the bitmap, using the passed in translation,\nwill draw a pixel at the indicated point.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "bmp": {
          "type": "bitmap",
          "description": "The bitmap to test.",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "cell": {
          "type": "int",
          "description": "The cell of the bitmap to check.",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "translation": {
          "type": "matrix_2d",
          "description": "The translation matrix that represents the position, scale,\nand rotation of the bitmap when it is drawn.",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "pt": {
          "type": "point_2d",
          "description": "The point in the resulting drawing that is being tested.",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "bitmap",
        "method": "point_collision",
        "suffix": "for_cell_with_translation",
        "group": "physics",
        "static": "collisions",
        "self": "bmp"
      },
      "signatures": {
        "cpp": [
          "bool bitmap_point_collision(bitmap bmp, int cell, const matrix_2d &translation, const point_2d &pt)"
        ],
        "rust": [
          "pub fn bitmap_point_collision(bmp: bitmap, cell: i32, translation: &matrix_2d, pt: &point_2d) -> bool"
        ],
        "python": [
          "def bitmap_point_collision_for_cell_with_translation(bmp, cell, translation, pt):"
        ],
        "pascal": [
          "function BitmapPointCollision(bmp: Bitmap; cell: Integer; const translation: Matrix2D; const pt: Point2D): Boolean"
        ],
        "csharp": [
          "public bool Bitmap.BitmapPointCollision(int cell, Matrix2D translation, Point2D pt);",
          "public static bool SplashKit.BitmapPointCollision(Bitmap bmp, int cell, Matrix2D translation, Point2D pt);"
        ]
      }
    },
    {
      "signature": "bool bitmap_point_collision(bitmap bmp,int cell,const point_2d &bmp_pt,const point_2d& pt);",
      "name": "bitmap_point_collision",
      "method_name": "point_collision",
      "unique_global_name": "bitmap_point_collision_for_cell_at_point",
      "unique_method_name": "bitmap.point_collision_for_cell_at_point",
      "suffix_name": null,
      "description": "Tests if a cell of a bitmap drawn at x,y would draw a pixel at the passed in point. Use\nto check collisions between a point and a bitmap.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if drawing the bitmap cell, at the indicated location,\nwill draw a pixel at the indicated point.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "bmp": {
          "type": "bitmap",
          "description": "The bitmap to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "cell": {
          "type": "int",
          "description": "The cell of the bitmap to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "bmp_pt": {
          "type": "point_2d",
          "description": "The point where the bitmap is drawn.",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "pt": {
          "type": "point_2d",
          "description": "The point in the resulting drawing that is being tested.",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "bitmap",
        "method": "point_collision",
        "suffix": "for_cell_at_point",
        "group": "physics",
        "static": "collisions",
        "self": "bmp"
      },
      "signatures": {
        "cpp": [
          "bool bitmap_point_collision(bitmap bmp, int cell, const point_2d &bmp_pt, const point_2d &pt)"
        ],
        "rust": [
          "pub fn bitmap_point_collision(bmp: bitmap, cell: i32, bmp_pt: &point_2d, pt: &point_2d) -> bool"
        ],
        "python": [
          "def bitmap_point_collision_for_cell_at_point(bmp, cell, bmp_pt, pt):"
        ],
        "pascal": [
          "function BitmapPointCollision(bmp: Bitmap; cell: Integer; const bmpPt: Point2D; const pt: Point2D): Boolean"
        ],
        "csharp": [
          "public bool Bitmap.BitmapPointCollision(int cell, Point2D bmpPt, Point2D pt);",
          "public static bool SplashKit.BitmapPointCollision(Bitmap bmp, int cell, Point2D bmpPt, Point2D pt);"
        ]
      }
    },
    {
      "signature": "bool bitmap_point_collision(bitmap bmp,int cell,double bmp_x,double bmp_y,double x,double y);",
      "name": "bitmap_point_collision",
      "method_name": "point_collision",
      "unique_global_name": "bitmap_point_collision_for_cell",
      "unique_method_name": "bitmap.point_collision_for_cell",
      "suffix_name": null,
      "description": "Tests if a cell of a bitmap drawn at x,y would draw a pixel at the passed in point. Use\nto check collisions between a point and a bitmap.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if drawing the bitmap cell, at the indicated location,\nwill draw a pixel at the indicated point.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "bmp": {
          "type": "bitmap",
          "description": "The bitmap to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "cell": {
          "type": "int",
          "description": "The cell of the bitmap to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "bmp_x": {
          "type": "double",
          "description": "The x location where the bitmap is drawn",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "bmp_y": {
          "type": "double",
          "description": "The y location where the bitmap is drawn",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "x": {
          "type": "double",
          "description": "The x location of the point to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "y": {
          "type": "double",
          "description": "The y location of the point to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "bitmap",
        "method": "point_collision",
        "suffix": "for_cell",
        "group": "physics",
        "static": "collisions",
        "self": "bmp"
      },
      "signatures": {
        "cpp": [
          "bool bitmap_point_collision(bitmap bmp, int cell, double bmp_x, double bmp_y, double x, double y)"
        ],
        "rust": [
          "pub fn bitmap_point_collision(bmp: bitmap, cell: i32, bmp_x: f64, bmp_y: f64, x: f64, y: f64) -> bool"
        ],
        "python": [
          "def bitmap_point_collision_for_cell(bmp, cell, bmp_x, bmp_y, x, y):"
        ],
        "pascal": [
          "function BitmapPointCollision(bmp: Bitmap; cell: Integer; bmpX: Double; bmpY: Double; x: Double; y: Double): Boolean"
        ],
        "csharp": [
          "public bool Bitmap.BitmapPointCollision(int cell, double bmpX, double bmpY, double x, double y);",
          "public static bool SplashKit.BitmapPointCollision(Bitmap bmp, int cell, double bmpX, double bmpY, double x, double y);"
        ]
      }
    },
    {
      "signature": "bool bitmap_rectangle_collision(bitmap bmp,const point_2d& pt,const rectangle& rect);",
      "name": "bitmap_rectangle_collision",
      "method_name": "rectangle_collision",
      "unique_global_name": "bitmap_rectangle_collision_at_point",
      "unique_method_name": "bitmap.rectangle_collision_at_point",
      "suffix_name": null,
      "description": "Tests if a bitmap drawn at `pt` would intersect with a rectangle.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if a drawn pixel in the cell of the bitmap will\nintersect with `rect` when drawn.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "bmp": {
          "type": "bitmap",
          "description": "The bitmap to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "pt": {
          "type": "point_2d",
          "description": "The location where the bitmap is drawn",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "rect": {
          "type": "rectangle",
          "description": "The rectangle to test",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "bitmap",
        "method": "rectangle_collision",
        "suffix": "at_point",
        "group": "physics",
        "static": "collisions",
        "self": "bmp"
      },
      "signatures": {
        "cpp": [
          "bool bitmap_rectangle_collision(bitmap bmp, const point_2d &pt, const rectangle &rect)"
        ],
        "rust": [
          "pub fn bitmap_rectangle_collision(bmp: bitmap, pt: &point_2d, rect: &rectangle) -> bool"
        ],
        "python": [
          "def bitmap_rectangle_collision_at_point(bmp, pt, rect):"
        ],
        "pascal": [
          "function BitmapRectangleCollision(bmp: Bitmap; const pt: Point2D; const rect: Rectangle): Boolean"
        ],
        "csharp": [
          "public bool Bitmap.BitmapRectangleCollision(Point2D pt, Rectangle rect);",
          "public static bool SplashKit.BitmapRectangleCollision(Bitmap bmp, Point2D pt, Rectangle rect);"
        ]
      }
    },
    {
      "signature": "bool bitmap_rectangle_collision(bitmap bmp,double x,double y,const rectangle& rect);",
      "name": "bitmap_rectangle_collision",
      "method_name": "rectangle_collision",
      "unique_global_name": "bitmap_rectangle_collision",
      "unique_method_name": "bitmap.rectangle_collision",
      "suffix_name": null,
      "description": "Tests if a bitmap drawn at `x`, `y` would intersect with a rectangle.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if a drawn pixel in the bitmap will\nintersect with `rect` when drawn.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "bmp": {
          "type": "bitmap",
          "description": "The bitmap to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "x": {
          "type": "double",
          "description": "The x location where the bitmap is drawn",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "y": {
          "type": "double",
          "description": "The y location where the bitmap is drawn",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "rect": {
          "type": "rectangle",
          "description": "The rectangle to test",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "bitmap",
        "method": "rectangle_collision",
        "group": "physics",
        "static": "collisions",
        "self": "bmp"
      },
      "signatures": {
        "cpp": [
          "bool bitmap_rectangle_collision(bitmap bmp, double x, double y, const rectangle &rect)"
        ],
        "rust": [
          "pub fn bitmap_rectangle_collision(bmp: bitmap, x: f64, y: f64, rect: &rectangle) -> bool"
        ],
        "python": [
          "def bitmap_rectangle_collision(bmp, x, y, rect):"
        ],
        "pascal": [
          "function BitmapRectangleCollision(bmp: Bitmap; x: Double; y: Double; const rect: Rectangle): Boolean"
        ],
        "csharp": [
          "public bool Bitmap.BitmapRectangleCollision(double x, double y, Rectangle rect);",
          "public static bool SplashKit.BitmapRectangleCollision(Bitmap bmp, double x, double y, Rectangle rect);"
        ]
      }
    },
    {
      "signature": "bool bitmap_rectangle_collision(bitmap bmp,int cell,const matrix_2d& translation,const rectangle& rect);",
      "name": "bitmap_rectangle_collision",
      "method_name": "rectangle_collision",
      "unique_global_name": "bitmap_rectangle_collision_for_cell_with_translation",
      "unique_method_name": "bitmap.rectangle_collision_for_cell_with_translation",
      "suffix_name": null,
      "description": "Tests if a bitmap cell drawn using a passed in translation, will\nintersect with a rectangle. You can use this to detect collisions between\nbitmaps and rectangles.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if a drawn pixel in the cell of the bitmap will\nintersect with `rect` when drawn.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "bmp": {
          "type": "bitmap",
          "description": "The bitmap to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "cell": {
          "type": "int",
          "description": "The cell of the bitmap to check",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "translation": {
          "type": "matrix_2d",
          "description": "The matrix used to transfrom the bitmap when drawing",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "rect": {
          "type": "rectangle",
          "description": "The rectangle to test",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "bitmap",
        "method": "rectangle_collision",
        "suffix": "for_cell_with_translation",
        "group": "physics",
        "static": "collisions",
        "self": "bmp"
      },
      "signatures": {
        "cpp": [
          "bool bitmap_rectangle_collision(bitmap bmp, int cell, const matrix_2d &translation, const rectangle &rect)"
        ],
        "rust": [
          "pub fn bitmap_rectangle_collision(bmp: bitmap, cell: i32, translation: &matrix_2d, rect: &rectangle) -> bool"
        ],
        "python": [
          "def bitmap_rectangle_collision_for_cell_with_translation(bmp, cell, translation, rect):"
        ],
        "pascal": [
          "function BitmapRectangleCollision(bmp: Bitmap; cell: Integer; const translation: Matrix2D; const rect: Rectangle): Boolean"
        ],
        "csharp": [
          "public bool Bitmap.BitmapRectangleCollision(int cell, Matrix2D translation, Rectangle rect);",
          "public static bool SplashKit.BitmapRectangleCollision(Bitmap bmp, int cell, Matrix2D translation, Rectangle rect);"
        ]
      }
    },
    {
      "signature": "bool bitmap_rectangle_collision(bitmap bmp,int cell,const point_2d& pt,const rectangle& rect);",
      "name": "bitmap_rectangle_collision",
      "method_name": "rectangle_collision",
      "unique_global_name": "bitmap_rectangle_collision_for_cell_at_point",
      "unique_method_name": "bitmap.rectangle_collision_for_cell_at_point",
      "suffix_name": null,
      "description": "Tests if a bitmap cell drawn at `pt` would intersect with a rectangle.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if a drawn pixel in the cell of the bitmap will\nintersect with `rect` when drawn.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "bmp": {
          "type": "bitmap",
          "description": "The bitmap to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "cell": {
          "type": "int",
          "description": "The cell of the bitmap to check",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "pt": {
          "type": "point_2d",
          "description": "The location where the bitmap is drawn",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "rect": {
          "type": "rectangle",
          "description": "The rectangle to test",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "bitmap",
        "method": "rectangle_collision",
        "suffix": "for_cell_at_point",
        "group": "physics",
        "static": "collisions",
        "self": "bmp"
      },
      "signatures": {
        "cpp": [
          "bool bitmap_rectangle_collision(bitmap bmp, int cell, const point_2d &pt, const rectangle &rect)"
        ],
        "rust": [
          "pub fn bitmap_rectangle_collision(bmp: bitmap, cell: i32, pt: &point_2d, rect: &rectangle) -> bool"
        ],
        "python": [
          "def bitmap_rectangle_collision_for_cell_at_point(bmp, cell, pt, rect):"
        ],
        "pascal": [
          "function BitmapRectangleCollision(bmp: Bitmap; cell: Integer; const pt: Point2D; const rect: Rectangle): Boolean"
        ],
        "csharp": [
          "public bool Bitmap.BitmapRectangleCollision(int cell, Point2D pt, Rectangle rect);",
          "public static bool SplashKit.BitmapRectangleCollision(Bitmap bmp, int cell, Point2D pt, Rectangle rect);"
        ]
      }
    },
    {
      "signature": "bool bitmap_rectangle_collision(bitmap bmp,int cell,double x,double y,const rectangle& rect);",
      "name": "bitmap_rectangle_collision",
      "method_name": "rectangle_collision",
      "unique_global_name": "bitmap_rectangle_collision_for_cell",
      "unique_method_name": "bitmap.rectangle_collision_for_cell",
      "suffix_name": null,
      "description": "Tests if a cell of the bitmap drawn at `x`, `y` would intersect with a rectangle.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if a drawn pixel in the bitmap will\nintersect with `rect` when drawn.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "bmp": {
          "type": "bitmap",
          "description": "The bitmap to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "cell": {
          "type": "int",
          "description": "The cell of the bitmap to check",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "x": {
          "type": "double",
          "description": "The x location where the bitmap is drawn",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "y": {
          "type": "double",
          "description": "The y location where the bitmap is drawn",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "rect": {
          "type": "rectangle",
          "description": "The rectangle to test",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "bitmap",
        "method": "rectangle_collision",
        "suffix": "for_cell",
        "group": "physics",
        "static": "collisions",
        "self": "bmp"
      },
      "signatures": {
        "cpp": [
          "bool bitmap_rectangle_collision(bitmap bmp, int cell, double x, double y, const rectangle &rect)"
        ],
        "rust": [
          "pub fn bitmap_rectangle_collision(bmp: bitmap, cell: i32, x: f64, y: f64, rect: &rectangle) -> bool"
        ],
        "python": [
          "def bitmap_rectangle_collision_for_cell(bmp, cell, x, y, rect):"
        ],
        "pascal": [
          "function BitmapRectangleCollision(bmp: Bitmap; cell: Integer; x: Double; y: Double; const rect: Rectangle): Boolean"
        ],
        "csharp": [
          "public bool Bitmap.BitmapRectangleCollision(int cell, double x, double y, Rectangle rect);",
          "public static bool SplashKit.BitmapRectangleCollision(Bitmap bmp, int cell, double x, double y, Rectangle rect);"
        ]
      }
    },
    {
      "signature": "bool sprite_bitmap_collision(sprite s,bitmap bmp,double x,double y);",
      "name": "sprite_bitmap_collision",
      "method_name": "bitmap_collision",
      "unique_global_name": "sprite_bitmap_collision",
      "unique_method_name": "sprite.bitmap_collision",
      "suffix_name": null,
      "description": "Tests if a sprite will collide with a bitmap drawn at the indicated\nlocation.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if the sprite collides with the bitmap when drawn\nat the indicated location.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "s": {
          "type": "sprite",
          "description": "The sprite to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "bmp": {
          "type": "bitmap",
          "description": "The bitmap to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "x": {
          "type": "double",
          "description": "The x location where the bitmap is drawn",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "y": {
          "type": "double",
          "description": "The y location where the bitmap is drawn",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "sprite",
        "method": "bitmap_collision",
        "group": "physics",
        "static": "collisions",
        "self": "s"
      },
      "signatures": {
        "cpp": [
          "bool sprite_bitmap_collision(sprite s, bitmap bmp, double x, double y)"
        ],
        "rust": [
          "pub fn sprite_bitmap_collision(s: sprite, bmp: bitmap, x: f64, y: f64) -> bool"
        ],
        "python": [
          "def sprite_bitmap_collision(s, bmp, x, y):"
        ],
        "pascal": [
          "function SpriteBitmapCollision(s: Sprite; bmp: Bitmap; x: Double; y: Double): Boolean"
        ],
        "csharp": [
          "public bool Sprite.SpriteBitmapCollision(Bitmap bmp, double x, double y);",
          "public static bool SplashKit.SpriteBitmapCollision(Sprite s, Bitmap bmp, double x, double y);"
        ]
      }
    },
    {
      "signature": "bool sprite_bitmap_collision(sprite s,bitmap bmp,int cell,const point_2d &pt);",
      "name": "sprite_bitmap_collision",
      "method_name": "bitmap_collision",
      "unique_global_name": "sprite_bitmap_collision_with_cell_at_point",
      "unique_method_name": "sprite.bitmap_collision_with_cell_at_point",
      "suffix_name": null,
      "description": "Tests if a sprite will collide with a bitmap drawn at the indicated\nlocation.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if the sprite collides with the bitmap cell when drawn\nat the indicated location.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "s": {
          "type": "sprite",
          "description": "The sprite to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "bmp": {
          "type": "bitmap",
          "description": "The bitmap to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "cell": {
          "type": "int",
          "description": "The cell of the bitmap to check",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "pt": {
          "type": "point_2d",
          "description": "The point where the bitmap is drawn",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "sprite",
        "method": "bitmap_collision",
        "suffix": "with_cell_at_point",
        "group": "physics",
        "static": "collisions",
        "self": "s"
      },
      "signatures": {
        "cpp": [
          "bool sprite_bitmap_collision(sprite s, bitmap bmp, int cell, const point_2d &pt)"
        ],
        "rust": [
          "pub fn sprite_bitmap_collision(s: sprite, bmp: bitmap, cell: i32, pt: &point_2d) -> bool"
        ],
        "python": [
          "def sprite_bitmap_collision_with_cell_at_point(s, bmp, cell, pt):"
        ],
        "pascal": [
          "function SpriteBitmapCollision(s: Sprite; bmp: Bitmap; cell: Integer; const pt: Point2D): Boolean"
        ],
        "csharp": [
          "public bool Sprite.SpriteBitmapCollision(Bitmap bmp, int cell, Point2D pt);",
          "public static bool SplashKit.SpriteBitmapCollision(Sprite s, Bitmap bmp, int cell, Point2D pt);"
        ]
      }
    },
    {
      "signature": "bool sprite_bitmap_collision(sprite s,bitmap bmp,int cell,double x,double y);",
      "name": "sprite_bitmap_collision",
      "method_name": "bitmap_collision",
      "unique_global_name": "sprite_bitmap_collision_with_cell",
      "unique_method_name": "sprite.bitmap_collision_with_cell",
      "suffix_name": null,
      "description": "Tests if a sprite will collide with a bitmap drawn at the indicated\nlocation.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if the sprite collides with the bitmap cell when drawn\nat the indicated location.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "s": {
          "type": "sprite",
          "description": "The sprite to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "bmp": {
          "type": "bitmap",
          "description": "The bitmap to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "cell": {
          "type": "int",
          "description": "The cell of the bitmap to check",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "x": {
          "type": "double",
          "description": "The x location where the bitmap is drawn",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "y": {
          "type": "double",
          "description": "The y location where the bitmap is drawn",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "sprite",
        "method": "bitmap_collision",
        "suffix": "with_cell",
        "group": "physics",
        "static": "collisions",
        "self": "s"
      },
      "signatures": {
        "cpp": [
          "bool sprite_bitmap_collision(sprite s, bitmap bmp, int cell, double x, double y)"
        ],
        "rust": [
          "pub fn sprite_bitmap_collision(s: sprite, bmp: bitmap, cell: i32, x: f64, y: f64) -> bool"
        ],
        "python": [
          "def sprite_bitmap_collision_with_cell(s, bmp, cell, x, y):"
        ],
        "pascal": [
          "function SpriteBitmapCollision(s: Sprite; bmp: Bitmap; cell: Integer; x: Double; y: Double): Boolean"
        ],
        "csharp": [
          "public bool Sprite.SpriteBitmapCollision(Bitmap bmp, int cell, double x, double y);",
          "public static bool SplashKit.SpriteBitmapCollision(Sprite s, Bitmap bmp, int cell, double x, double y);"
        ]
      }
    },
    {
      "signature": "bool sprite_collision(sprite s1,sprite s2);",
      "name": "sprite_collision",
      "method_name": "sprite_collision",
      "unique_global_name": "sprite_collision",
      "unique_method_name": "sprite.sprite_collision",
      "suffix_name": null,
      "description": "Tests if two given sprites `s1` and `s2` are collided",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "return `true` if both `s1` and `s2` are colliding, false otherwise.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "s1": {
          "type": "sprite",
          "description": "the first `sprite` to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "s2": {
          "type": "sprite",
          "description": "the second `sprite` to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "sprite",
        "method": "sprite_collision",
        "self": "s1",
        "group": "physics",
        "static": "collisions"
      },
      "signatures": {
        "cpp": [
          "bool sprite_collision(sprite s1, sprite s2)"
        ],
        "rust": [
          "pub fn sprite_collision(s1: sprite, s2: sprite) -> bool"
        ],
        "python": [
          "def sprite_collision(s1, s2):"
        ],
        "pascal": [
          "function SpriteCollision(s1: Sprite; s2: Sprite): Boolean"
        ],
        "csharp": [
          "public bool Sprite.SpriteCollision(Sprite s2);",
          "public static bool SplashKit.SpriteCollision(Sprite s1, Sprite s2);"
        ]
      }
    },
    {
      "signature": "bool sprite_point_collision(sprite s,const point_2d& pt);",
      "name": "sprite_point_collision",
      "method_name": "point_collision",
      "unique_global_name": "sprite_point_collision",
      "unique_method_name": "sprite.point_collision",
      "suffix_name": null,
      "description": "Tests if a sprite is drawn at a given point.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if the sprite it drawn at the indicated point",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "s": {
          "type": "sprite",
          "description": "The sprite to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "pt": {
          "type": "point_2d",
          "description": "The point to check",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "sprite",
        "method": "point_collision",
        "group": "physics",
        "static": "collisions",
        "self": "s"
      },
      "signatures": {
        "cpp": [
          "bool sprite_point_collision(sprite s, const point_2d &pt)"
        ],
        "rust": [
          "pub fn sprite_point_collision(s: sprite, pt: &point_2d) -> bool"
        ],
        "python": [
          "def sprite_point_collision(s, pt):"
        ],
        "pascal": [
          "function SpritePointCollision(s: Sprite; const pt: Point2D): Boolean"
        ],
        "csharp": [
          "public bool Sprite.SpritePointCollision(Point2D pt);",
          "public static bool SplashKit.SpritePointCollision(Sprite s, Point2D pt);"
        ]
      }
    },
    {
      "signature": "bool sprite_rectangle_collision(sprite s,const rectangle& rect);",
      "name": "sprite_rectangle_collision",
      "method_name": "rectangle_collision",
      "unique_global_name": "sprite_rectangle_collision",
      "unique_method_name": "sprite.rectangle_collision",
      "suffix_name": null,
      "description": "Tests if a sprite is drawn within an given area (rectangle).",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if the sprite it drawn in the rectangle area",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "s": {
          "type": "sprite",
          "description": "The sprite to test",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "rect": {
          "type": "rectangle",
          "description": "The rectangle to check",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "class": "sprite",
        "method": "rectangle_collision",
        "group": "physics",
        "static": "collisions",
        "self": "s"
      },
      "signatures": {
        "cpp": [
          "bool sprite_rectangle_collision(sprite s, const rectangle &rect)"
        ],
        "rust": [
          "pub fn sprite_rectangle_collision(s: sprite, rect: &rectangle) -> bool"
        ],
        "python": [
          "def sprite_rectangle_collision(s, rect):"
        ],
        "pascal": [
          "function SpriteRectangleCollision(s: Sprite; const rect: Rectangle): Boolean"
        ],
        "csharp": [
          "public bool Sprite.SpriteRectangleCollision(Rectangle rect);",
          "public static bool SplashKit.SpriteRectangleCollision(Sprite s, Rectangle rect);"
        ]
      }
    },
    {
      "signature": "void apply_matrix(const matrix_2d &matrix,quad &q);",
      "name": "apply_matrix",
      "method_name": null,
      "unique_global_name": "apply_matrix_to_quad",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Use a matrix to transform all of the points in a quad.",
      "brief": null,
      "return": {
        "type": "void",
        "description": null,
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "matrix": {
          "type": "matrix_2d",
          "description": "The matrix with the transformations needed.",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "q": {
          "type": "quad",
          "description": "The quad to transform.",
          "is_pointer": false,
          "is_const": false,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "suffix": "to_quad",
        "group": "physics",
        "static": "matrix_2d"
      },
      "signatures": {
        "cpp": [
          "void apply_matrix(const matrix_2d &matrix, quad &q)"
        ],
        "rust": [
          "pub fn apply_matrix(matrix: &matrix_2d, q: &mut quad)"
        ],
        "python": [
          "def apply_matrix_to_quad(matrix, q):"
        ],
        "pascal": [
          "procedure ApplyMatrix(const matrix: Matrix2D; var q: Quad)"
        ],
        "csharp": [
          "public static void Matrix2D.ApplyMatrix(Matrix2D matrix, ref Quad q);",
          "public static void SplashKit.ApplyMatrix(Matrix2D matrix, ref Quad q);"
        ]
      }
    },
    {
      "signature": "void apply_matrix(const matrix_2d &m,triangle &tri);",
      "name": "apply_matrix",
      "method_name": null,
      "unique_global_name": "apply_matrix_to_triangle",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Use a matrix to transform all of the points in a triangle.",
      "brief": null,
      "return": {
        "type": "void",
        "description": null,
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "m": {
          "type": "matrix_2d",
          "description": "The matrix to be applied to the triangle.",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "tri": {
          "type": "triangle",
          "description": "The triangle to tranform.",
          "is_pointer": false,
          "is_const": false,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "suffix": "to_triangle",
        "group": "physics",
        "static": "matrix_2d"
      },
      "signatures": {
        "cpp": [
          "void apply_matrix(const matrix_2d &m, triangle &tri)"
        ],
        "rust": [
          "pub fn apply_matrix(m: &matrix_2d, tri: &mut triangle)"
        ],
        "python": [
          "def apply_matrix_to_triangle(m, tri):"
        ],
        "pascal": [
          "procedure ApplyMatrix(const m: Matrix2D; var tri: Triangle)"
        ],
        "csharp": [
          "public static void Matrix2D.ApplyMatrix(Matrix2D m, ref Triangle tri);",
          "public static void SplashKit.ApplyMatrix(Matrix2D m, ref Triangle tri);"
        ]
      }
    },
    {
      "signature": "matrix_2d identity_matrix();",
      "name": "identity_matrix",
      "method_name": null,
      "unique_global_name": "identity_matrix",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Returns the identity matrix. When a matrix_2d or Vector is multiplied by\nthe identity matrix the result is the original matrix or vector.",
      "brief": null,
      "return": {
        "type": "matrix_2d",
        "description": "An identify matrix.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {},
      "attributes": {
        "group": "physics",
        "static": "matrix_2d"
      },
      "signatures": {
        "cpp": [
          "matrix_2d identity_matrix()"
        ],
        "rust": [
          "pub fn identity_matrix() -> matrix_2d"
        ],
        "python": [
          "def identity_matrix():"
        ],
        "pascal": [
          "function IdentityMatrix(): Matrix2D"
        ],
        "csharp": [
          "public static Matrix2D Matrix2D.IdentityMatrix();",
          "public static Matrix2D SplashKit.IdentityMatrix();"
        ]
      }
    },
    {
      "signature": "matrix_2d matrix_inverse(const matrix_2d &m);",
      "name": "matrix_inverse",
      "method_name": null,
      "unique_global_name": "matrix_inverse",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Calculate the inverse of a matrix.",
      "brief": null,
      "return": {
        "type": "matrix_2d",
        "description": "A matrix that is the inverse of m",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "m": {
          "type": "matrix_2d",
          "description": "The matrix to invert.",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "matrix_2d"
      },
      "signatures": {
        "cpp": [
          "matrix_2d matrix_inverse(const matrix_2d &m)"
        ],
        "rust": [
          "pub fn matrix_inverse(m: &matrix_2d) -> matrix_2d"
        ],
        "python": [
          "def matrix_inverse(m):"
        ],
        "pascal": [
          "function MatrixInverse(const m: Matrix2D): Matrix2D"
        ],
        "csharp": [
          "public static Matrix2D Matrix2D.MatrixInverse(Matrix2D m);",
          "public static Matrix2D SplashKit.MatrixInverse(Matrix2D m);"
        ]
      }
    },
    {
      "signature": "point_2d matrix_multiply(const matrix_2d &m,const point_2d &pt);",
      "name": "matrix_multiply",
      "method_name": null,
      "unique_global_name": "matrix_multiply_point",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Multiplies the `point_2d` parameter `v with the `matrix_2d` `m and\nreturns the result as a `point_2d`. Use this to transform the vector with\nthe matrix (to apply scaling, rotation or translation effects).",
      "brief": null,
      "return": {
        "type": "point_2d",
        "description": "A new point, the result of applying the transformation to pt.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "m": {
          "type": "matrix_2d",
          "description": "The matrix with the transformation to apply.",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "pt": {
          "type": "point_2d",
          "description": "The point to be transformed.",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "suffix": "point",
        "group": "physics",
        "static": "matrix_2d"
      },
      "signatures": {
        "cpp": [
          "point_2d matrix_multiply(const matrix_2d &m, const point_2d &pt)"
        ],
        "rust": [
          "pub fn matrix_multiply(m: &matrix_2d, pt: &point_2d) -> point_2d"
        ],
        "python": [
          "def matrix_multiply_point(m, pt):"
        ],
        "pascal": [
          "function MatrixMultiply(const m: Matrix2D; const pt: Point2D): Point2D"
        ],
        "csharp": [
          "public static Point2D Matrix2D.MatrixMultiply(Matrix2D m, Point2D pt);",
          "public static Point2D SplashKit.MatrixMultiply(Matrix2D m, Point2D pt);"
        ]
      }
    },
    {
      "signature": "matrix_2d matrix_multiply(const matrix_2d &m1,const matrix_2d &m2);",
      "name": "matrix_multiply",
      "method_name": null,
      "unique_global_name": "matrix_multiply_matrix",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Multiplies the two `matrix_2d` parameters, `m1` by `m2`, and returns\nthe result as a new `matrix_2d`. Use this to combine the effects to two\nmatrix transformations.",
      "brief": null,
      "return": {
        "type": "matrix_2d",
        "description": "The result of multiplying m1 by m2",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "m1": {
          "type": "matrix_2d",
          "description": "The first matrix",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "m2": {
          "type": "matrix_2d",
          "description": "The second matrix",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "suffix": "matrix",
        "group": "physics",
        "static": "matrix_2d"
      },
      "signatures": {
        "cpp": [
          "matrix_2d matrix_multiply(const matrix_2d &m1, const matrix_2d &m2)"
        ],
        "rust": [
          "pub fn matrix_multiply(m1: &matrix_2d, m2: &matrix_2d) -> matrix_2d"
        ],
        "python": [
          "def matrix_multiply_matrix(m1, m2):"
        ],
        "pascal": [
          "function MatrixMultiply(const m1: Matrix2D; const m2: Matrix2D): Matrix2D"
        ],
        "csharp": [
          "public static Matrix2D Matrix2D.MatrixMultiply(Matrix2D m1, Matrix2D m2);",
          "public static Matrix2D SplashKit.MatrixMultiply(Matrix2D m1, Matrix2D m2);"
        ]
      }
    },
    {
      "signature": "vector_2d matrix_multiply(const matrix_2d &m,const vector_2d &v);",
      "name": "matrix_multiply",
      "method_name": null,
      "unique_global_name": "matrix_multiply_vector",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Multiplies the `Vector` parameter `v` with the `matrix_2d` `m` and\nreturns the result as a `Vector`. Use this to transform the vector with\nthe matrix (to apply scaling, rotation or translation effects).",
      "brief": null,
      "return": {
        "type": "vector_2d",
        "description": "A new vector, the result of applying the transformation to v.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "m": {
          "type": "matrix_2d",
          "description": "The matrix with the transformation to apply.",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "v": {
          "type": "vector_2d",
          "description": "The vector to be transformed.",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "suffix": "vector",
        "group": "physics",
        "static": "matrix_2d"
      },
      "signatures": {
        "cpp": [
          "vector_2d matrix_multiply(const matrix_2d &m, const vector_2d &v)"
        ],
        "rust": [
          "pub fn matrix_multiply(m: &matrix_2d, v: &vector_2d) -> vector_2d"
        ],
        "python": [
          "def matrix_multiply_vector(m, v):"
        ],
        "pascal": [
          "function MatrixMultiply(const m: Matrix2D; const v: Vector2D): Vector2D"
        ],
        "csharp": [
          "public static Vector2D Matrix2D.MatrixMultiply(Matrix2D m, Vector2D v);",
          "public static Vector2D SplashKit.MatrixMultiply(Matrix2D m, Vector2D v);"
        ]
      }
    },
    {
      "signature": "string matrix_to_string(const matrix_2d &matrix);",
      "name": "matrix_to_string",
      "method_name": null,
      "unique_global_name": "matrix_to_string",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "This function returns a string representation of a Matrix.",
      "brief": null,
      "return": {
        "type": "string",
        "description": "A string representation of the matrix.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "matrix": {
          "type": "matrix_2d",
          "description": "The matrix to convert to a string.",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "matrix_2d"
      },
      "signatures": {
        "cpp": [
          "string matrix_to_string(const matrix_2d &matrix)"
        ],
        "rust": [
          "pub fn matrix_to_string(matrix: &matrix_2d) -> String"
        ],
        "python": [
          "def matrix_to_string(matrix):"
        ],
        "pascal": [
          "function MatrixToString(const matrix: Matrix2D): String"
        ],
        "csharp": [
          "public static string Matrix2D.MatrixToString(Matrix2D matrix);",
          "public static string SplashKit.MatrixToString(Matrix2D matrix);"
        ]
      }
    },
    {
      "signature": "matrix_2d rotation_matrix(double deg);",
      "name": "rotation_matrix",
      "method_name": null,
      "unique_global_name": "rotation_matrix",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Returns a rotation matrix that rotates 2d points by the angle.",
      "brief": null,
      "return": {
        "type": "matrix_2d",
        "description": "A matrix that encodes the rotation by a number of degrees.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "deg": {
          "type": "double",
          "description": "The amount to rotate points",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "matrix_2d"
      },
      "signatures": {
        "cpp": [
          "matrix_2d rotation_matrix(double deg)"
        ],
        "rust": [
          "pub fn rotation_matrix(deg: f64) -> matrix_2d"
        ],
        "python": [
          "def rotation_matrix(deg):"
        ],
        "pascal": [
          "function RotationMatrix(deg: Double): Matrix2D"
        ],
        "csharp": [
          "public static Matrix2D Matrix2D.RotationMatrix(double deg);",
          "public static Matrix2D SplashKit.RotationMatrix(double deg);"
        ]
      }
    },
    {
      "signature": "matrix_2d scale_matrix(const point_2d &scale);",
      "name": "scale_matrix",
      "method_name": null,
      "unique_global_name": "scale_matrix_from_point",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Create a scale matrix that scales x and y to\ndifferent degrees.",
      "brief": null,
      "return": {
        "type": "matrix_2d",
        "description": "A matrix that will scale points based on scale parameter.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "scale": {
          "type": "point_2d",
          "description": "The amount to scale, with separate x and y components.",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "suffix": "from_point",
        "group": "physics",
        "static": "matrix_2d"
      },
      "signatures": {
        "cpp": [
          "matrix_2d scale_matrix(const point_2d &scale)"
        ],
        "rust": [
          "pub fn scale_matrix(scale: &point_2d) -> matrix_2d"
        ],
        "python": [
          "def scale_matrix_from_point(scale):"
        ],
        "pascal": [
          "function ScaleMatrix(const scale: Point2D): Matrix2D"
        ],
        "csharp": [
          "public static Matrix2D Matrix2D.ScaleMatrix(Point2D scale);",
          "public static Matrix2D SplashKit.ScaleMatrix(Point2D scale);"
        ]
      }
    },
    {
      "signature": "matrix_2d scale_matrix(const vector_2d &scale);",
      "name": "scale_matrix",
      "method_name": null,
      "unique_global_name": "scale_matrix_from_vector",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Create a scale matrix that scales x and y to\ndifferent degrees.",
      "brief": null,
      "return": {
        "type": "matrix_2d",
        "description": "A matrix that will scale points based on scale parameter.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "scale": {
          "type": "vector_2d",
          "description": "The amount to scale, with separate x and y components.",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "suffix": "from_vector",
        "group": "physics",
        "static": "matrix_2d"
      },
      "signatures": {
        "cpp": [
          "matrix_2d scale_matrix(const vector_2d &scale)"
        ],
        "rust": [
          "pub fn scale_matrix(scale: &vector_2d) -> matrix_2d"
        ],
        "python": [
          "def scale_matrix_from_vector(scale):"
        ],
        "pascal": [
          "function ScaleMatrix(const scale: Vector2D): Matrix2D"
        ],
        "csharp": [
          "public static Matrix2D Matrix2D.ScaleMatrix(Vector2D scale);",
          "public static Matrix2D SplashKit.ScaleMatrix(Vector2D scale);"
        ]
      }
    },
    {
      "signature": "matrix_2d scale_matrix(double scale);",
      "name": "scale_matrix",
      "method_name": null,
      "unique_global_name": "scale_matrix",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Returns a matrix that can be used to scale 2d points (both x and y).",
      "brief": null,
      "return": {
        "type": "matrix_2d",
        "description": "A matrix to scale points by.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "scale": {
          "type": "double",
          "description": "The amount to scale points by.",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "matrix_2d"
      },
      "signatures": {
        "cpp": [
          "matrix_2d scale_matrix(double scale)"
        ],
        "rust": [
          "pub fn scale_matrix(scale: f64) -> matrix_2d"
        ],
        "python": [
          "def scale_matrix(scale):"
        ],
        "pascal": [
          "function ScaleMatrix(scale: Double): Matrix2D"
        ],
        "csharp": [
          "public static Matrix2D Matrix2D.ScaleMatrix(double scale);",
          "public static Matrix2D SplashKit.ScaleMatrix(double scale);"
        ]
      }
    },
    {
      "signature": "matrix_2d scale_rotate_translate_matrix(const point_2d &scale,double deg,const point_2d &translate);",
      "name": "scale_rotate_translate_matrix",
      "method_name": null,
      "unique_global_name": "scale_rotate_translate_matrix",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Create a matrix that can scale, rotate then translate geometry points.",
      "brief": null,
      "return": {
        "type": "matrix_2d",
        "description": "A matrix that will scale, rotate, and translate.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "scale": {
          "type": "point_2d",
          "description": "The amount to scale",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "deg": {
          "type": "double",
          "description": "The amount to rotate",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "translate": {
          "type": "point_2d",
          "description": "The amount to move",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "matrix_2d"
      },
      "signatures": {
        "cpp": [
          "matrix_2d scale_rotate_translate_matrix(const point_2d &scale, double deg, const point_2d &translate)"
        ],
        "rust": [
          "pub fn scale_rotate_translate_matrix(scale: &point_2d, deg: f64, translate: &point_2d) -> matrix_2d"
        ],
        "python": [
          "def scale_rotate_translate_matrix(scale, deg, translate):"
        ],
        "pascal": [
          "function ScaleRotateTranslateMatrix(const scale: Point2D; deg: Double; const translate: Point2D): Matrix2D"
        ],
        "csharp": [
          "public static Matrix2D Matrix2D.ScaleRotateTranslateMatrix(Point2D scale, double deg, Point2D translate);",
          "public static Matrix2D SplashKit.ScaleRotateTranslateMatrix(Point2D scale, double deg, Point2D translate);"
        ]
      }
    },
    {
      "signature": "matrix_2d translation_matrix(const point_2d &pt);",
      "name": "translation_matrix",
      "method_name": null,
      "unique_global_name": "translation_matrix_to_point",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Returns a translation matric used to translate 2d points by the\ndistance in the point_2d.",
      "brief": null,
      "return": {
        "type": "matrix_2d",
        "description": "A matrix that will move points by amount in pt",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "pt": {
          "type": "point_2d",
          "description": "The point to translate to.",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "suffix": "to_point",
        "group": "physics",
        "static": "matrix_2d"
      },
      "signatures": {
        "cpp": [
          "matrix_2d translation_matrix(const point_2d &pt)"
        ],
        "rust": [
          "pub fn translation_matrix(pt: &point_2d) -> matrix_2d"
        ],
        "python": [
          "def translation_matrix_to_point(pt):"
        ],
        "pascal": [
          "function TranslationMatrix(const pt: Point2D): Matrix2D"
        ],
        "csharp": [
          "public static Matrix2D Matrix2D.TranslationMatrix(Point2D pt);",
          "public static Matrix2D SplashKit.TranslationMatrix(Point2D pt);"
        ]
      }
    },
    {
      "signature": "matrix_2d translation_matrix(const vector_2d &pt);",
      "name": "translation_matrix",
      "method_name": null,
      "unique_global_name": "translation_matrix_from_vector",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Returns a translation matric used to translate 2d points by the\ndistance in the vector_2d.",
      "brief": null,
      "return": {
        "type": "matrix_2d",
        "description": "A matrix that will move points by amount in pt",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "pt": {
          "type": "vector_2d",
          "description": "The point to translate to.",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "suffix": "from_vector",
        "group": "physics",
        "static": "matrix_2d"
      },
      "signatures": {
        "cpp": [
          "matrix_2d translation_matrix(const vector_2d &pt)"
        ],
        "rust": [
          "pub fn translation_matrix(pt: &vector_2d) -> matrix_2d"
        ],
        "python": [
          "def translation_matrix_from_vector(pt):"
        ],
        "pascal": [
          "function TranslationMatrix(const pt: Vector2D): Matrix2D"
        ],
        "csharp": [
          "public static Matrix2D Matrix2D.TranslationMatrix(Vector2D pt);",
          "public static Matrix2D SplashKit.TranslationMatrix(Vector2D pt);"
        ]
      }
    },
    {
      "signature": "matrix_2d translation_matrix(double dx,double dy);",
      "name": "translation_matrix",
      "method_name": null,
      "unique_global_name": "translation_matrix",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Returns a matrix that can be used to translate 2d points. Moving them\nby dx and dy.",
      "brief": null,
      "return": {
        "type": "matrix_2d",
        "description": "A matrix that will move points by dx, dy",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "dx": {
          "type": "double",
          "description": "The amount to move points along the x axis.",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "dy": {
          "type": "double",
          "description": "The amount to move points along the y axis.",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "matrix_2d"
      },
      "signatures": {
        "cpp": [
          "matrix_2d translation_matrix(double dx, double dy)"
        ],
        "rust": [
          "pub fn translation_matrix(dx: f64, dy: f64) -> matrix_2d"
        ],
        "python": [
          "def translation_matrix(dx, dy):"
        ],
        "pascal": [
          "function TranslationMatrix(dx: Double; dy: Double): Matrix2D"
        ],
        "csharp": [
          "public static Matrix2D Matrix2D.TranslationMatrix(double dx, double dy);",
          "public static Matrix2D SplashKit.TranslationMatrix(double dx, double dy);"
        ]
      }
    },
    {
      "signature": "double angle_between(const vector_2d &v1,const vector_2d &v2);",
      "name": "angle_between",
      "method_name": null,
      "unique_global_name": "angle_between",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Calculates the angle from one vector to another.",
      "brief": null,
      "return": {
        "type": "double",
        "description": "The angle of the line from the end of `v1` to the end of `v2`",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "v1": {
          "type": "vector_2d",
          "description": "The first vector",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "v2": {
          "type": "vector_2d",
          "description": "The second vector",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "double angle_between(const vector_2d &v1, const vector_2d &v2)"
        ],
        "rust": [
          "pub fn angle_between(v1: &vector_2d, v2: &vector_2d) -> f64"
        ],
        "python": [
          "def angle_between(v1, v2):"
        ],
        "pascal": [
          "function AngleBetween(const v1: Vector2D; const v2: Vector2D): Double"
        ],
        "csharp": [
          "public static double Vector2D.AngleBetween(Vector2D v1, Vector2D v2);",
          "public static double SplashKit.AngleBetween(Vector2D v1, Vector2D v2);"
        ]
      }
    },
    {
      "signature": "double dot_product(const vector_2d &v1,const vector_2d &v2);",
      "name": "dot_product",
      "method_name": null,
      "unique_global_name": "dot_product",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Calculates the dot product (scalar product) between the two vector\nparameters provided (`v1` and `v2`). It returns the result as a\nscalar value.\n\nIf the result is 0.0 it means that the vectors are orthogonal (at right\nangles to each other). If `v1` and `v2` are unit vectors (length of\n1.0) and the dot product is 1.0, it means that `v1` and `v2` vectors\nare parallel.",
      "brief": null,
      "return": {
        "type": "double",
        "description": "The dot product of `v1` . `v2`",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "v1": {
          "type": "vector_2d",
          "description": "The first vector",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "v2": {
          "type": "vector_2d",
          "description": "The other vector",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "double dot_product(const vector_2d &v1, const vector_2d &v2)"
        ],
        "rust": [
          "pub fn dot_product(v1: &vector_2d, v2: &vector_2d) -> f64"
        ],
        "python": [
          "def dot_product(v1, v2):"
        ],
        "pascal": [
          "function DotProduct(const v1: Vector2D; const v2: Vector2D): Double"
        ],
        "csharp": [
          "public static double Vector2D.DotProduct(Vector2D v1, Vector2D v2);",
          "public static double SplashKit.DotProduct(Vector2D v1, Vector2D v2);"
        ]
      }
    },
    {
      "signature": "bool is_zero_vector(const vector_2d &v);",
      "name": "is_zero_vector",
      "method_name": null,
      "unique_global_name": "is_zero_vector",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Returns if the vector is a null/zero vector -- having no size or direction.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if `v` has no magnitude.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "v": {
          "type": "vector_2d",
          "description": "The vector",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "bool is_zero_vector(const vector_2d &v)"
        ],
        "rust": [
          "pub fn is_zero_vector(v: &vector_2d) -> bool"
        ],
        "python": [
          "def is_zero_vector(v):"
        ],
        "pascal": [
          "function IsZeroVector(const v: Vector2D): Boolean"
        ],
        "csharp": [
          "public static bool Vector2D.IsZeroVector(Vector2D v);",
          "public static bool SplashKit.IsZeroVector(Vector2D v);"
        ]
      }
    },
    {
      "signature": "bool ray_intersection_point(const point_2d &from_pt,const vector_2d &heading,const line &l,point_2d &pt);",
      "name": "ray_intersection_point",
      "method_name": null,
      "unique_global_name": "ray_intersection_point",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Casts a ray in a heading and returns true is it intersects with a line",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if the line and ray will intersect, in which case\nthe value of `pt` will be changed to be the point where\nthe intersection occurs.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "from_pt": {
          "type": "point_2d",
          "description": "The origin of the ray",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "heading": {
          "type": "vector_2d",
          "description": "The direction the ray is heading (as a `vector_2d`)",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "l": {
          "type": "line",
          "description": "The line to be checked",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "pt": {
          "type": "point_2d",
          "description": "Outputs the point where the line and ray intersect",
          "is_pointer": false,
          "is_const": false,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "bool ray_intersection_point(const point_2d &from_pt, const vector_2d &heading, const line &l, point_2d &pt)"
        ],
        "rust": [
          "pub fn ray_intersection_point(from_pt: &point_2d, heading: &vector_2d, l: &line, pt: &mut point_2d) -> bool"
        ],
        "python": [
          "def ray_intersection_point(from_pt, heading, l, pt):"
        ],
        "pascal": [
          "function RayIntersectionPoint(const fromPt: Point2D; const heading: Vector2D; const l: Line; var pt: Point2D): Boolean"
        ],
        "csharp": [
          "public static bool Vector2D.RayIntersectionPoint(Point2D fromPt, Vector2D heading, Line l, ref Point2D pt);",
          "public static bool SplashKit.RayIntersectionPoint(Point2D fromPt, Vector2D heading, Line l, ref Point2D pt);"
        ]
      }
    },
    {
      "signature": "vector_2d unit_vector(const vector_2d &v);",
      "name": "unit_vector",
      "method_name": null,
      "unique_global_name": "unit_vector",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Returns the unit vector of the parameter vector (v). The unit vector has a\nmagnitude of 1, resulting in a vector that indicates the direction of\nthe original vector.",
      "brief": null,
      "return": {
        "type": "vector_2d",
        "description": "The unit vector of `v`",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "v": {
          "type": "vector_2d",
          "description": "The vector",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "vector_2d unit_vector(const vector_2d &v)"
        ],
        "rust": [
          "pub fn unit_vector(v: &vector_2d) -> vector_2d"
        ],
        "python": [
          "def unit_vector(v):"
        ],
        "pascal": [
          "function UnitVector(const v: Vector2D): Vector2D"
        ],
        "csharp": [
          "public static Vector2D Vector2D.UnitVector(Vector2D v);",
          "public static Vector2D SplashKit.UnitVector(Vector2D v);"
        ]
      }
    },
    {
      "signature": "vector_2d vector_add(const vector_2d &v1,const vector_2d &v2);",
      "name": "vector_add",
      "method_name": null,
      "unique_global_name": "vector_add",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Adds the two passed in vectors returns the result as new `vector_2d`.",
      "brief": null,
      "return": {
        "type": "vector_2d",
        "description": "The result of adding the movements of the two vectors\ntogether.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "v1": {
          "type": "vector_2d",
          "description": "The first vector.",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "v2": {
          "type": "vector_2d",
          "description": "The other vector.",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "vector_2d vector_add(const vector_2d &v1, const vector_2d &v2)"
        ],
        "rust": [
          "pub fn vector_add(v1: &vector_2d, v2: &vector_2d) -> vector_2d"
        ],
        "python": [
          "def vector_add(v1, v2):"
        ],
        "pascal": [
          "function VectorAdd(const v1: Vector2D; const v2: Vector2D): Vector2D"
        ],
        "csharp": [
          "public static Vector2D Vector2D.VectorAdd(Vector2D v1, Vector2D v2);",
          "public static Vector2D SplashKit.VectorAdd(Vector2D v1, Vector2D v2);"
        ]
      }
    },
    {
      "signature": "double vector_angle(const vector_2d v);",
      "name": "vector_angle",
      "method_name": null,
      "unique_global_name": "vector_angle",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Calculates the angle of a vector",
      "brief": null,
      "return": {
        "type": "double",
        "description": "The angle of the vector in degrees",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "v": {
          "type": "vector_2d",
          "description": "The vector",
          "is_pointer": false,
          "is_const": true,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "double vector_angle(const vector_2d v)"
        ],
        "rust": [
          "pub fn vector_angle(v: vector_2d) -> f64"
        ],
        "python": [
          "def vector_angle(v):"
        ],
        "pascal": [
          "function VectorAngle(v: Vector2D): Double"
        ],
        "csharp": [
          "public static double Vector2D.VectorAngle(Vector2D v);",
          "public static double SplashKit.VectorAngle(Vector2D v);"
        ]
      }
    },
    {
      "signature": "vector_2d vector_from_angle(double angle,double magnitude);",
      "name": "vector_from_angle",
      "method_name": null,
      "unique_global_name": "vector_from_angle",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Returns a `vector_2d` from the supplied angle and distance.",
      "brief": null,
      "return": {
        "type": "vector_2d",
        "description": "A vector that will move things at that angle and\nmagnitude",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "angle": {
          "type": "double",
          "description": "The angle in degrees",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "magnitude": {
          "type": "double",
          "description": "The length of the vector",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "vector_2d vector_from_angle(double angle, double magnitude)"
        ],
        "rust": [
          "pub fn vector_from_angle(angle: f64, magnitude: f64) -> vector_2d"
        ],
        "python": [
          "def vector_from_angle(angle, magnitude):"
        ],
        "pascal": [
          "function VectorFromAngle(angle: Double; magnitude: Double): Vector2D"
        ],
        "csharp": [
          "public static Vector2D Vector2D.VectorFromAngle(double angle, double magnitude);",
          "public static Vector2D SplashKit.VectorFromAngle(double angle, double magnitude);"
        ]
      }
    },
    {
      "signature": "vector_2d vector_from_line(const line &l);",
      "name": "vector_from_line",
      "method_name": null,
      "unique_global_name": "vector_from_line",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Returns a vector that points from the start to the end of a line.",
      "brief": null,
      "return": {
        "type": "vector_2d",
        "description": "A vector that will move things from the start to the end of the\nline",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "l": {
          "type": "line",
          "description": "The line",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "vector_2d vector_from_line(const line &l)"
        ],
        "rust": [
          "pub fn vector_from_line(l: &line) -> vector_2d"
        ],
        "python": [
          "def vector_from_line(l):"
        ],
        "pascal": [
          "function VectorFromLine(const l: Line): Vector2D"
        ],
        "csharp": [
          "public static Vector2D Vector2D.VectorFromLine(Line l);",
          "public static Vector2D SplashKit.VectorFromLine(Line l);"
        ]
      }
    },
    {
      "signature": "vector_2d vector_from_point_to_rect(const point_2d &pt,const rectangle &rect);",
      "name": "vector_from_point_to_rect",
      "method_name": null,
      "unique_global_name": "vector_from_point_to_rect",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Returns a vector from a point to a rectangle.",
      "brief": null,
      "return": {
        "type": "vector_2d",
        "description": "A vector representing the distance and direction from `pt`\nto `rect`",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "pt": {
          "type": "point_2d",
          "description": "The point",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "rect": {
          "type": "rectangle",
          "description": "The rectangle",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "vector_2d vector_from_point_to_rect(const point_2d &pt, const rectangle &rect)"
        ],
        "rust": [
          "pub fn vector_from_point_to_rect(pt: &point_2d, rect: &rectangle) -> vector_2d"
        ],
        "python": [
          "def vector_from_point_to_rect(pt, rect):"
        ],
        "pascal": [
          "function VectorFromPointToRect(const pt: Point2D; const rect: Rectangle): Vector2D"
        ],
        "csharp": [
          "public static Vector2D Vector2D.VectorFromPointToRect(Point2D pt, Rectangle rect);",
          "public static Vector2D SplashKit.VectorFromPointToRect(Point2D pt, Rectangle rect);"
        ]
      }
    },
    {
      "signature": "bool vector_in_rect(const vector_2d &v,const rectangle &rect);",
      "name": "vector_in_rect",
      "method_name": null,
      "unique_global_name": "vector_in_rect",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Returns true if the resulting vector would end in the rectangle if\nplaced at the origin.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if the vector would end in the rectangle",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "v": {
          "type": "vector_2d",
          "description": "The vector",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "rect": {
          "type": "rectangle",
          "description": "The rectangle",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "bool vector_in_rect(const vector_2d &v, const rectangle &rect)"
        ],
        "rust": [
          "pub fn vector_in_rect(v: &vector_2d, rect: &rectangle) -> bool"
        ],
        "python": [
          "def vector_in_rect(v, rect):"
        ],
        "pascal": [
          "function VectorInRect(const v: Vector2D; const rect: Rectangle): Boolean"
        ],
        "csharp": [
          "public static bool Vector2D.VectorInRect(Vector2D v, Rectangle rect);",
          "public static bool SplashKit.VectorInRect(Vector2D v, Rectangle rect);"
        ]
      }
    },
    {
      "signature": "vector_2d vector_invert(const vector_2d &v);",
      "name": "vector_invert",
      "method_name": null,
      "unique_global_name": "vector_invert",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Returns a new Vector that is an inverted version of the parameter\nvector (v). In other words, the -/+ sign of the x and y values are changed.",
      "brief": null,
      "return": {
        "type": "vector_2d",
        "description": "The inverse (reverse) of `v`",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "v": {
          "type": "vector_2d",
          "description": "The vector",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "vector_2d vector_invert(const vector_2d &v)"
        ],
        "rust": [
          "pub fn vector_invert(v: &vector_2d) -> vector_2d"
        ],
        "python": [
          "def vector_invert(v):"
        ],
        "pascal": [
          "function VectorInvert(const v: Vector2D): Vector2D"
        ],
        "csharp": [
          "public static Vector2D Vector2D.VectorInvert(Vector2D v);",
          "public static Vector2D SplashKit.VectorInvert(Vector2D v);"
        ]
      }
    },
    {
      "signature": "vector_2d vector_limit(const vector_2d &v,double limit);",
      "name": "vector_limit",
      "method_name": null,
      "unique_global_name": "vector_limit",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Returns a scaled vector that ensures the new vector points\nin the same direction as v, but has a magnitude that is\nlimited to the length specified in the limit prameter.",
      "brief": null,
      "return": {
        "type": "vector_2d",
        "description": "A new vector in the same direction as v, but with a\nmagnitude that is less than or equal to the limit.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "v": {
          "type": "vector_2d",
          "description": "The vector",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "limit": {
          "type": "double",
          "description": "Its maximum magnitude",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "vector_2d vector_limit(const vector_2d &v, double limit)"
        ],
        "rust": [
          "pub fn vector_limit(v: &vector_2d, limit: f64) -> vector_2d"
        ],
        "python": [
          "def vector_limit(v, limit):"
        ],
        "pascal": [
          "function VectorLimit(const v: Vector2D; limit: Double): Vector2D"
        ],
        "csharp": [
          "public static Vector2D Vector2D.VectorLimit(Vector2D v, double limit);",
          "public static Vector2D SplashKit.VectorLimit(Vector2D v, double limit);"
        ]
      }
    },
    {
      "signature": "double vector_magnitude(const vector_2d &v);",
      "name": "vector_magnitude",
      "method_name": null,
      "unique_global_name": "vector_magnitude",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Returns the magnitude (or \"length\") of the vector.",
      "brief": null,
      "return": {
        "type": "double",
        "description": "Its magnitude",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "v": {
          "type": "vector_2d",
          "description": "The vector",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "double vector_magnitude(const vector_2d &v)"
        ],
        "rust": [
          "pub fn vector_magnitude(v: &vector_2d) -> f64"
        ],
        "python": [
          "def vector_magnitude(v):"
        ],
        "pascal": [
          "function VectorMagnitude(const v: Vector2D): Double"
        ],
        "csharp": [
          "public static double Vector2D.VectorMagnitude(Vector2D v);",
          "public static double SplashKit.VectorMagnitude(Vector2D v);"
        ]
      }
    },
    {
      "signature": "double vector_magnitude_squared(const vector_2d &v);",
      "name": "vector_magnitude_squared",
      "method_name": null,
      "unique_global_name": "vector_magnitude_squared",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Returns the squared magnitude (or \"length\") of the vector.",
      "brief": null,
      "return": {
        "type": "double",
        "description": "Its squared magnitude",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "v": {
          "type": "vector_2d",
          "description": "The vector",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "double vector_magnitude_squared(const vector_2d &v)"
        ],
        "rust": [
          "pub fn vector_magnitude_squared(v: &vector_2d) -> f64"
        ],
        "python": [
          "def vector_magnitude_squared(v):"
        ],
        "pascal": [
          "function VectorMagnitudeSquared(const v: Vector2D): Double"
        ],
        "csharp": [
          "public static double Vector2D.VectorMagnitudeSquared(Vector2D v);",
          "public static double SplashKit.VectorMagnitudeSquared(Vector2D v);"
        ]
      }
    },
    {
      "signature": "vector_2d vector_multiply(const vector_2d &v1,double s);",
      "name": "vector_multiply",
      "method_name": null,
      "unique_global_name": "vector_multiply",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Multiplies the vector by the passed in value.",
      "brief": null,
      "return": {
        "type": "vector_2d",
        "description": "A new vector",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "v1": {
          "type": "vector_2d",
          "description": "The original vector",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "s": {
          "type": "double",
          "description": "The amount to multiply by",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "vector_2d vector_multiply(const vector_2d &v1, double s)"
        ],
        "rust": [
          "pub fn vector_multiply(v1: &vector_2d, s: f64) -> vector_2d"
        ],
        "python": [
          "def vector_multiply(v1, s):"
        ],
        "pascal": [
          "function VectorMultiply(const v1: Vector2D; s: Double): Vector2D"
        ],
        "csharp": [
          "public static Vector2D Vector2D.VectorMultiply(Vector2D v1, double s);",
          "public static Vector2D SplashKit.VectorMultiply(Vector2D v1, double s);"
        ]
      }
    },
    {
      "signature": "vector_2d vector_normal(const vector_2d &v);",
      "name": "vector_normal",
      "method_name": null,
      "unique_global_name": "vector_normal",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Returns a new `vector_2d` that is perpendicular (\"normal\") to the parameter\nvector `v` provided. The concept of a \"normal\" vector is usually\nextracted from (or associated with) a line.\n\nNote: when passed a zero or null vector (a vector with no\nmagnitude or direction) then this function returns a zero/null vector.",
      "brief": null,
      "return": {
        "type": "vector_2d",
        "description": "The normal of `v`",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "v": {
          "type": "vector_2d",
          "description": "The vector",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "vector_2d vector_normal(const vector_2d &v)"
        ],
        "rust": [
          "pub fn vector_normal(v: &vector_2d) -> vector_2d"
        ],
        "python": [
          "def vector_normal(v):"
        ],
        "pascal": [
          "function VectorNormal(const v: Vector2D): Vector2D"
        ],
        "csharp": [
          "public static Vector2D Vector2D.VectorNormal(Vector2D v);",
          "public static Vector2D SplashKit.VectorNormal(Vector2D v);"
        ]
      }
    },
    {
      "signature": "vector_2d vector_out_of_circle_from_circle(const circle &src,const circle &bounds,const vector_2d &velocity);",
      "name": "vector_out_of_circle_from_circle",
      "method_name": null,
      "unique_global_name": "vector_out_of_circle_from_circle",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Returns a vector to back one circle out of another, assuming the first circle was\nmoving at a specified velocity.",
      "brief": null,
      "return": {
        "type": "vector_2d",
        "description": "A vector that can move the circle out of the bounds",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "src": {
          "type": "circle",
          "description": "The circle that is moving",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "bounds": {
          "type": "circle",
          "description": "The area you want to move the circle out of",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "velocity": {
          "type": "vector_2d",
          "description": "The circle's velocity",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "vector_2d vector_out_of_circle_from_circle(const circle &src, const circle &bounds, const vector_2d &velocity)"
        ],
        "rust": [
          "pub fn vector_out_of_circle_from_circle(src: &circle, bounds: &circle, velocity: &vector_2d) -> vector_2d"
        ],
        "python": [
          "def vector_out_of_circle_from_circle(src, bounds, velocity):"
        ],
        "pascal": [
          "function VectorOutOfCircleFromCircle(const src: Circle; const bounds: Circle; const velocity: Vector2D): Vector2D"
        ],
        "csharp": [
          "public static Vector2D Vector2D.VectorOutOfCircleFromCircle(Circle src, Circle bounds, Vector2D velocity);",
          "public static Vector2D SplashKit.VectorOutOfCircleFromCircle(Circle src, Circle bounds, Vector2D velocity);"
        ]
      }
    },
    {
      "signature": "vector_2d vector_out_of_circle_from_point(const point_2d &pt,const circle &c,const vector_2d &velocity);",
      "name": "vector_out_of_circle_from_point",
      "method_name": null,
      "unique_global_name": "vector_out_of_circle_from_point",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Returns the vector out to move a point back out of a circle,\ngiven the point was moving at the specified velocity.",
      "brief": null,
      "return": {
        "type": "vector_2d",
        "description": "A vector that can move the point out of the circle",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "pt": {
          "type": "point_2d",
          "description": "The point that is moving",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "c": {
          "type": "circle",
          "description": "The circle you want to move the point out of",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "velocity": {
          "type": "vector_2d",
          "description": "The point's velocity",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "vector_2d vector_out_of_circle_from_point(const point_2d &pt, const circle &c, const vector_2d &velocity)"
        ],
        "rust": [
          "pub fn vector_out_of_circle_from_point(pt: &point_2d, c: &circle, velocity: &vector_2d) -> vector_2d"
        ],
        "python": [
          "def vector_out_of_circle_from_point(pt, c, velocity):"
        ],
        "pascal": [
          "function VectorOutOfCircleFromPoint(const pt: Point2D; const c: Circle; const velocity: Vector2D): Vector2D"
        ],
        "csharp": [
          "public static Vector2D Vector2D.VectorOutOfCircleFromPoint(Point2D pt, Circle c, Vector2D velocity);",
          "public static Vector2D SplashKit.VectorOutOfCircleFromPoint(Point2D pt, Circle c, Vector2D velocity);"
        ]
      }
    },
    {
      "signature": "vector_2d vector_out_of_rect_from_circle(const circle &c,const rectangle &rect,const vector_2d &velocity);",
      "name": "vector_out_of_rect_from_circle",
      "method_name": null,
      "unique_global_name": "vector_out_of_rect_from_circle",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Returns a vector that can be used to move a circle back out of a rectangle,\ngiven that the circle is moving at the specified velocity.",
      "brief": null,
      "return": {
        "type": "vector_2d",
        "description": "A vector that will move the circle out of the rectangle",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "c": {
          "type": "circle",
          "description": "The circle that is moving",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "rect": {
          "type": "rectangle",
          "description": "The area you wan to move the circle out of",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "velocity": {
          "type": "vector_2d",
          "description": "The circle's velocity",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "vector_2d vector_out_of_rect_from_circle(const circle &c, const rectangle &rect, const vector_2d &velocity)"
        ],
        "rust": [
          "pub fn vector_out_of_rect_from_circle(c: &circle, rect: &rectangle, velocity: &vector_2d) -> vector_2d"
        ],
        "python": [
          "def vector_out_of_rect_from_circle(c, rect, velocity):"
        ],
        "pascal": [
          "function VectorOutOfRectFromCircle(const c: Circle; const rect: Rectangle; const velocity: Vector2D): Vector2D"
        ],
        "csharp": [
          "public static Vector2D Vector2D.VectorOutOfRectFromCircle(Circle c, Rectangle rect, Vector2D velocity);",
          "public static Vector2D SplashKit.VectorOutOfRectFromCircle(Circle c, Rectangle rect, Vector2D velocity);"
        ]
      }
    },
    {
      "signature": "vector_2d vector_out_of_rect_from_point(const point_2d &pt,const rectangle &rect,const vector_2d &velocity);",
      "name": "vector_out_of_rect_from_point",
      "method_name": null,
      "unique_global_name": "vector_out_of_rect_from_point",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Determines the vector needed to move back from point `pt` out of rectangle `rect` given\nthe point was moving at the velocity specified.",
      "brief": null,
      "return": {
        "type": "vector_2d",
        "description": "A vector that can move the point outside of the\nrectangle.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "pt": {
          "type": "point_2d",
          "description": "The point you want to move out of a rectangle",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "rect": {
          "type": "rectangle",
          "description": "The rectangle to move out of",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "velocity": {
          "type": "vector_2d",
          "description": "The velocity of the point. This is used to determine\nwhere the point should return to.",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "vector_2d vector_out_of_rect_from_point(const point_2d &pt, const rectangle &rect, const vector_2d &velocity)"
        ],
        "rust": [
          "pub fn vector_out_of_rect_from_point(pt: &point_2d, rect: &rectangle, velocity: &vector_2d) -> vector_2d"
        ],
        "python": [
          "def vector_out_of_rect_from_point(pt, rect, velocity):"
        ],
        "pascal": [
          "function VectorOutOfRectFromPoint(const pt: Point2D; const rect: Rectangle; const velocity: Vector2D): Vector2D"
        ],
        "csharp": [
          "public static Vector2D Vector2D.VectorOutOfRectFromPoint(Point2D pt, Rectangle rect, Vector2D velocity);",
          "public static Vector2D SplashKit.VectorOutOfRectFromPoint(Point2D pt, Rectangle rect, Vector2D velocity);"
        ]
      }
    },
    {
      "signature": "vector_2d vector_out_of_rect_from_rect(const rectangle &src,const rectangle &bounds,const vector_2d &velocity);",
      "name": "vector_out_of_rect_from_rect",
      "method_name": null,
      "unique_global_name": "vector_out_of_rect_from_rect",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Returns the vector needed to move rectangle `src` back out of rectangle `bounds`\nassuming the rectangle was moving at the velocity specified.",
      "brief": null,
      "return": {
        "type": "vector_2d",
        "description": "A vector that can move the rectangle out of the bounds",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "src": {
          "type": "rectangle",
          "description": "The rectangle you want to move.",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "bounds": {
          "type": "rectangle",
          "description": "The area you want to move the rectangle out of",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "velocity": {
          "type": "vector_2d",
          "description": "The velocity of the `src` rectangle",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "vector_2d vector_out_of_rect_from_rect(const rectangle &src, const rectangle &bounds, const vector_2d &velocity)"
        ],
        "rust": [
          "pub fn vector_out_of_rect_from_rect(src: &rectangle, bounds: &rectangle, velocity: &vector_2d) -> vector_2d"
        ],
        "python": [
          "def vector_out_of_rect_from_rect(src, bounds, velocity):"
        ],
        "pascal": [
          "function VectorOutOfRectFromRect(const src: Rectangle; const bounds: Rectangle; const velocity: Vector2D): Vector2D"
        ],
        "csharp": [
          "public static Vector2D Vector2D.VectorOutOfRectFromRect(Rectangle src, Rectangle bounds, Vector2D velocity);",
          "public static Vector2D SplashKit.VectorOutOfRectFromRect(Rectangle src, Rectangle bounds, Vector2D velocity);"
        ]
      }
    },
    {
      "signature": "vector_2d vector_point_to_point(const point_2d &start,const point_2d &end_pt);",
      "name": "vector_point_to_point",
      "method_name": null,
      "unique_global_name": "vector_point_to_point",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Returns a `vector_2d` created from the difference from the `p1` to\nthe second `p2` points (`Point2D`).",
      "brief": null,
      "return": {
        "type": "vector_2d",
        "description": "A vector that will move things from the starting point to\nthe ending point",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "start": {
          "type": "point_2d",
          "description": "The starting point",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "end_pt": {
          "type": "point_2d",
          "description": "The ending point",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "vector_2d vector_point_to_point(const point_2d &start, const point_2d &end_pt)"
        ],
        "rust": [
          "pub fn vector_point_to_point(start: &point_2d, end_pt: &point_2d) -> vector_2d"
        ],
        "python": [
          "def vector_point_to_point(start, end_pt):"
        ],
        "pascal": [
          "function VectorPointToPoint(const start: Point2D; const endPt: Point2D): Vector2D"
        ],
        "csharp": [
          "public static Vector2D Vector2D.VectorPointToPoint(Point2D start, Point2D endPt);",
          "public static Vector2D SplashKit.VectorPointToPoint(Point2D start, Point2D endPt);"
        ]
      }
    },
    {
      "signature": "vector_2d vector_subtract(const vector_2d &v1,const vector_2d &v2);",
      "name": "vector_subtract",
      "method_name": null,
      "unique_global_name": "vector_subtract",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Subtracts the second vector parameter (`v2`) from the first vector\n(`v1`) and returns the result as new `vector_2d`.",
      "brief": null,
      "return": {
        "type": "vector_2d",
        "description": "The result of subtracting the movements of `v2` from `v1`.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "v1": {
          "type": "vector_2d",
          "description": "The first vector.",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "v2": {
          "type": "vector_2d",
          "description": "The other vector.",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "vector_2d vector_subtract(const vector_2d &v1, const vector_2d &v2)"
        ],
        "rust": [
          "pub fn vector_subtract(v1: &vector_2d, v2: &vector_2d) -> vector_2d"
        ],
        "python": [
          "def vector_subtract(v1, v2):"
        ],
        "pascal": [
          "function VectorSubtract(const v1: Vector2D; const v2: Vector2D): Vector2D"
        ],
        "csharp": [
          "public static Vector2D Vector2D.VectorSubtract(Vector2D v1, Vector2D v2);",
          "public static Vector2D SplashKit.VectorSubtract(Vector2D v1, Vector2D v2);"
        ]
      }
    },
    {
      "signature": "vector_2d vector_to(const point_2d &p1);",
      "name": "vector_to",
      "method_name": null,
      "unique_global_name": "vector_to_point",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Returns a new `vector_2d` using the x and y value of a `point_2d` parameter.\nThis is a vector from the origin to that point.",
      "brief": null,
      "return": {
        "type": "vector_2d",
        "description": "A vector from the origin to `p1`",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "p1": {
          "type": "point_2d",
          "description": "The point",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "suffix": "point",
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "vector_2d vector_to(const point_2d &p1)"
        ],
        "rust": [
          "pub fn vector_to(p1: &point_2d) -> vector_2d"
        ],
        "python": [
          "def vector_to_point(p1):"
        ],
        "pascal": [
          "function VectorTo(const p1: Point2D): Vector2D"
        ],
        "csharp": [
          "public static Vector2D Vector2D.VectorTo(Point2D p1);",
          "public static Vector2D SplashKit.VectorTo(Point2D p1);"
        ]
      }
    },
    {
      "signature": "vector_2d vector_to(double x,double y);",
      "name": "vector_to",
      "method_name": null,
      "unique_global_name": "vector_to",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Returns a vector to the indicated point.",
      "brief": null,
      "return": {
        "type": "vector_2d",
        "description": "A vector that will move things the indicated amount",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "x": {
          "type": "double",
          "description": "The amount to move horizontally",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "y": {
          "type": "double",
          "description": "The amount to move vertically",
          "is_pointer": false,
          "is_const": false,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "vector_2d vector_to(double x, double y)"
        ],
        "rust": [
          "pub fn vector_to(x: f64, y: f64) -> vector_2d"
        ],
        "python": [
          "def vector_to(x, y):"
        ],
        "pascal": [
          "function VectorTo(x: Double; y: Double): Vector2D"
        ],
        "csharp": [
          "public static Vector2D Vector2D.VectorTo(double x, double y);",
          "public static Vector2D SplashKit.VectorTo(double x, double y);"
        ]
      }
    },
    {
      "signature": "string vector_to_string(const vector_2d &v);",
      "name": "vector_to_string",
      "method_name": null,
      "unique_global_name": "vector_to_string",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Get a text description of the `vector_2d`.",
      "brief": null,
      "return": {
        "type": "string",
        "description": "A string representation of the vector",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "v": {
          "type": "vector_2d",
          "description": "The vector",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "string vector_to_string(const vector_2d &v)"
        ],
        "rust": [
          "pub fn vector_to_string(v: &vector_2d) -> String"
        ],
        "python": [
          "def vector_to_string(v):"
        ],
        "pascal": [
          "function VectorToString(const v: Vector2D): String"
        ],
        "csharp": [
          "public static string Vector2D.VectorToString(Vector2D v);",
          "public static string SplashKit.VectorToString(Vector2D v);"
        ]
      }
    },
    {
      "signature": "bool vectors_equal(const vector_2d &v1,const vector_2d v2);",
      "name": "vectors_equal",
      "method_name": null,
      "unique_global_name": "vectors_equal",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Determines if two vectors are the same.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if the two vectors are equal.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "v1": {
          "type": "vector_2d",
          "description": "The first vector",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "v2": {
          "type": "vector_2d",
          "description": "The other vector",
          "is_pointer": false,
          "is_const": true,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "bool vectors_equal(const vector_2d &v1, const vector_2d v2)"
        ],
        "rust": [
          "pub fn vectors_equal(v1: &vector_2d, v2: vector_2d) -> bool"
        ],
        "python": [
          "def vectors_equal(v1, v2):"
        ],
        "pascal": [
          "function VectorsEqual(const v1: Vector2D; v2: Vector2D): Boolean"
        ],
        "csharp": [
          "public static bool Vector2D.VectorsEqual(Vector2D v1, Vector2D v2);",
          "public static bool SplashKit.VectorsEqual(Vector2D v1, Vector2D v2);"
        ]
      }
    },
    {
      "signature": "bool vectors_not_equal(const vector_2d &v1,const vector_2d v2);",
      "name": "vectors_not_equal",
      "method_name": null,
      "unique_global_name": "vectors_not_equal",
      "unique_method_name": null,
      "suffix_name": null,
      "description": "Determines if two vectors are not the same.",
      "brief": null,
      "return": {
        "type": "bool",
        "description": "True if the two vectors are different.",
        "is_pointer": false,
        "is_reference": false,
        "is_vector": false,
        "type_parameter": null
      },
      "parameters": {
        "v1": {
          "type": "vector_2d",
          "description": "The first vector",
          "is_pointer": false,
          "is_const": true,
          "is_reference": true,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        },
        "v2": {
          "type": "vector_2d",
          "description": "The other vector",
          "is_pointer": false,
          "is_const": true,
          "is_reference": false,
          "is_array": false,
          "array_dimension_sizes": [],
          "is_vector": false,
          "type_parameter": null
        }
      },
      "attributes": {
        "group": "physics",
        "static": "vector_2d"
      },
      "signatures": {
        "cpp": [
          "bool vectors_not_equal(const vector_2d &v1, const vector_2d v2)"
        ],
        "rust": [
          "pub fn vectors_not_equal(v1: &vector_2d, v2: vector_2d) -> bool"
        ],
        "python": [
          "def vectors_not_equal(v1, v2):"
        ],
        "pascal": [
          "function VectorsNotEqual(const v1: Vector2D; v2: Vector2D): Boolean"
        ],
        "csharp": [
          "public static bool Vector2D.VectorsNotEqual(Vector2D v1, Vector2D v2);",
          "public static bool SplashKit.VectorsNotEqual(Vector2D v1, Vector2D v2);"
        ]
      }
    }
  ]
}