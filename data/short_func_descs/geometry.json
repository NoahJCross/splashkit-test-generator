{
  "example": "#include <iostream>\nusing namespace std;\n\n#include \"geometry.h\"\n#include \"window_manager.h\"\n#include \"graphics.h\"\n#include \"input.h\"\n\nusing namespace splashkit_lib;\n\nvoid test_points()\n{\n point_2d p = point_at(10, 20);\n cout << \"Point is at 10,20\" << endl;\n cout << point_to_string(p) << endl;\n \n window w1 = open_window(\"Point Tests\", 600, 600);\n \n triangle t1 = triangle_from(10, 10, 50, 50, 70, 55);\n rectangle r1 = rectangle_from(200, 200, -75, -100);\n circle c1 = circle_at(300, 300, 100);\n circle c2 = circle_at(300, 300, -10);\n line l = line_from(point_at_origin(), random_screen_point());\n \n cout << \"Angle of line is \" << point_point_angle(point_at_origin(), l.end_point) << endl;\n \n while (not window_close_requested(w1))\n {\n process_events();\n \n clear_screen(COLOR_WHEAT);\n \n if ( point_in_triangle(mouse_position(), t1) )\n {\n fill_triangle(COLOR_TAN, t1);\n }\n draw_triangle(COLOR_RED, t1);\n\n if ( point_in_rectangle(mouse_position(), r1) )\n {\n fill_rectangle(COLOR_TAN, r1);\n }\n draw_rectangle(COLOR_RED, r1);\n\n if ( point_in_circle(mouse_position(), c1) )\n {\n fill_circle(COLOR_TAN, c1);\n }\n draw_circle(COLOR_RED, c1);\n \n \n if ( point_in_circle(mouse_position(), c2) )\n {\n fill_circle(COLOR_RED, c2);\n }\n draw_circle(COLOR_RED, c2);\n \n if ( point_on_line(mouse_position(), l))\n {\n fill_circle(COLOR_RED, circle_at(l.start_point, 5));\n fill_circle(COLOR_RED, circle_at(l.end_point, 5));\n }\n draw_line(COLOR_RED, l);\n \n refresh_screen();\n }\n \n close_window(w1);\n}\n\nvoid test_rectangle()\n{\n auto r1 = rectangle_from(10, 20, 30, 40);\n auto r2 = rectangle_from(15, 30, 100, 100);\n \n cout << \"Created rectangle 10,20 30x40\" << endl;\n cout << rectangle_to_string(r1) << endl;\n \n cout << \"Top (should be 20): \" << rectangle_top(r1) << endl;\n cout << \"Bottom (should be 60): \" << rectangle_bottom(r1) << endl;\n cout << \"Left (should be 10): \" << rectangle_left(r1) << endl;\n cout << \"Right (should be 40): \" << rectangle_right(r1) << endl;\n \n auto center = rectangle_center(r1);\n cout << \"Center (should be 25,40): \" << center.x << \",\" << center.y << endl;\n \n auto intersect = intersection(r1, r2);\n cout << \"Intersection should be 15,30 25x30\" << endl;\n cout << \"Intersection is \" << rectangle_to_string(intersect) << endl;\n \n auto t1 = triangle_from(300, 300, 350, 350, 370, 355);\n auto t2 = triangle_from(300, 100, 250, 250, 150, 250);\n auto c1 = circle_at(450, 450, 50);\n auto r3 = rectangle_around(t1);\n auto r4 = rectangle_around(t2);\n auto r5 = rectangle_around(c1);\n \n \n window w1 = open_window(\"Rectangle Tests\", 600, 800);\n while ( !window_close_requested(w1) ) {\n process_events();\n \n clear_screen(COLOR_WHEAT);\n \n draw_rectangle(COLOR_RED, r1);\n draw_rectangle(COLOR_RED, r2);\n draw_rectangle(COLOR_YELLOW, intersect);\n \n draw_triangle(COLOR_RED, t1);\n draw_triangle(COLOR_RED, t2);\n draw_circle(COLOR_RED, c1);\n \n draw_rectangle(COLOR_RED, r3);\n draw_rectangle(COLOR_RED, r4);\n draw_rectangle(COLOR_RED, r5);\n \n refresh_screen();\n }\n close_window(w1);\n}\n\nvoid test_lines()\n{\n std::vector<line> lines;\n lines.push_back(line_from(110, 100, 110, 150));\n lines.push_back(line_from(120, 100, 120, 150));\n lines.push_back(line_from(130, 100, 130, 150));\n\n int line_idx = 0;\n\n point_2d pt = point_at(100, 105);\n point_2d closest = closest_point_on_lines(pt, lines, line_idx);\n cout << \"Closest point should be (110,105 on line 0): \" << point_to_string(closest) << \" on line \" << line_idx << endl;\n\n pt = point_at(135, 108);\n closest = closest_point_on_lines(pt, lines, line_idx);\n cout << \"Closest point should be (130,108 on line 2): \" << point_to_string(closest) << \" on line \" << line_idx << endl;\n\n pt = point_at(121, 103);\n closest = closest_point_on_lines(pt, lines, line_idx);\n cout << \"Closest point (should be 120,103 on line 1): \" << point_to_string(closest) << \" on line \" << line_idx << endl;\n\n // no lines\n closest = closest_point_on_lines(pt, {}, line_idx);\n cout << \"Closest point (should be 0,0 on line -1): \" << point_to_string(closest) << \" on line \" << line_idx << endl;\n\n circle c1 = circle_at(300, 300, 2);\n\n lines.push_back(line_from(200, 200, 400, 400));\n lines.push_back(line_from(200, 400, 400, 200));\n lines.push_back(line_from(15, 15, 400, 30));\n lines.push_back(line_from(100, 500, 500, 400));\n lines.push_back(line_from(550, 700, 550, 790));\n lines.push_back(line_from(30, 550, 230, 650));\n\n window w1 = open_window(\"Line Tests\", 600, 800);\n while ( !window_close_requested(w1) ) {\n process_events();\n\n clear_screen(COLOR_WHEAT);\n\n c1.center = mouse_position();\n\n point_2d p1 = closest_point_on_lines(c1.center, lines, line_idx);\n\n for (int i = 0; i < lines.size(); i++)\n {\n if (i == line_idx)\n draw_line(COLOR_RED, lines[i]);\n else\n draw_line(COLOR_BLACK, lines[i]);\n }\n draw_circle(COLOR_RED, p1.x, p1.y, 5);\n fill_circle(COLOR_RED, c1);\n\n refresh_screen();\n }\n close_window(w1);\n}\n\nvoid test_triangle()\n{\n auto t1 = triangle_from(110, 110, 120, 150, 170, 190);\n auto t2 = triangle_from(200, 200, 200, 500, 500, 500);\n auto t3 = triangle_from(300, 20, 280, 240, 550, 60);\n auto t4 = triangle_from(150, 700, 265, 600, 510, 610);\n auto c1 = circle_at(300, 300, 50);\n\n window w1 = open_window(\"Triangle Tests\", 600, 800);\n while ( !window_close_requested(w1) ) {\n process_events();\n \n if (key_down(UP_KEY))\n c1.radius += 0.05;\n\n if (key_down(DOWN_KEY))\n c1.radius -= 0.05;\n\n clear_screen(COLOR_WHEAT);\n\n c1.center = mouse_position();\n\n point_2d p1, p2, p3, p4;\n\n if (circle_triangle_intersect(c1, t1, p1))\n fill_triangle(COLOR_TAN, t1);\n\n if (circle_triangle_intersect(c1, t2, p2))\n fill_triangle(COLOR_TAN, t2);\n\n if (circle_triangle_intersect(c1, t3, p3))\n fill_triangle(COLOR_TAN, t3);\n\n if (circle_triangle_intersect(c1, t4, p4))\n fill_triangle(COLOR_TAN, t4);\n\n draw_triangle(COLOR_RED, t1);\n draw_triangle(COLOR_RED, t2);\n draw_triangle(COLOR_RED, t3);\n draw_triangle(COLOR_RED, t4);\n\n draw_circle(COLOR_RED, p1.x, p1.y, 5);\n draw_circle(COLOR_RED, p2.x, p2.y, 5);\n draw_circle(COLOR_RED, p3.x, p3.y, 5);\n draw_circle(COLOR_RED, p4.x, p4.y, 5);\n\n draw_circle(COLOR_RED, c1);\n\n refresh_screen();\n }\n close_window(w1);\n}\n\nvoid run_geometry_test()\n{\n test_rectangle();\n test_points();\n test_lines();\n test_triangle();\n}//\n//  test_shape_drawing.cpp\n//  splashkit\n//\n//  Created by Andrew Cain on 17/08/2016.\n//  Copyright Â© 2016 Andrew Cain. All rights reserved.\n//\n\n#include <iostream>\nusing namespace std;\n\n#include \"input.h\"\n#include \"graphics.h\"\n#include \"geometry.h\"\n#include \"text.h\"\n#include \"timers.h\"\n#include \"window_manager.h\"\n#include \"random.h\"\n#include \"images.h\"\n\nusing namespace splashkit_lib;\n\nvoid test_circle_drawing(window w1)\n{\n    timer t = create_timer(\"shape drawing timer\");\n    start_timer(t);\n\n    clear_screen(COLOR_WHITE);\n    draw_text(\"Drawing Circles\", COLOR_TOMATO, \"myfont\", 18, 30, 30);\n    \n    while( not window_close_requested(w1) and timer_ticks(t) < 3000 )\n    {\n        process_events();\n        \n        if ( timer_ticks(t) < 1500)\n            draw_circle(random_rgb_color(128), rnd() * screen_width(), rnd() * screen_height(), 1 + rnd() * 50);\n        else\n        {\n            circle c = circle_at(rnd() * window_width(w1), rnd() * window_height(\"Test Shape Drawing\"), 1 + rnd() * 50);\n            draw_circle(random_rgb_color(128), c);\n        }\n        \n        refresh_screen();\n    }\n    cout << \"Saving circles screenshot to desktop\" << endl;\n    take_screenshot(\"circles\");\n    \n    reset_timer(t);\n    clear_screen(COLOR_WHITE);\n    draw_text(\"Filling Circles\", COLOR_TOMATO, \"myfont\", 18, 30, 30);\n    \n    while( not window_close_requested(w1) and timer_ticks(t) < 3000 )\n    {\n        process_events();\n        \n        if ( timer_ticks(t) < 1500)\n            fill_circle(random_rgb_color(128), rnd() * screen_width(), rnd() * screen_height(), 1 + rnd() * 50);\n        else\n        {\n            circle c = circle_at(rnd() * window_width(w1), rnd() * window_height(\"Test Shape Drawing\"), 1 + rnd() * 50);\n            fill_circle(random_rgb_color(128), c);\n        }\n        \n        refresh_screen();\n    }\n    cout << \"Saving filled circles screenshot to desktop\" << endl;\n    take_screenshot(current_window(), \"filled circles\");\n    \n    reset_timer(t);\n    clear_screen(COLOR_WHITE);\n    draw_text(\"Draw Circle to Bitmap\", COLOR_TOMATO, \"myfont\", 18, 30, 30);\n    \n    bitmap bmp = create_bitmap(\"bitmap\", 300, 300);\n    drawing_options opts = option_draw_to(bmp);\n    \n    clear_bitmap(bmp, COLOR_WHEAT);\n    \n    while( not window_close_requested(w1) and timer_ticks(t) < 3000 )\n    {\n        process_events();\n        \n        if ( timer_ticks(t) < 1500)\n        {\n            draw_circle(random_rgb_color(128), rnd() * bitmap_width(\"bitmap\"), rnd() * bitmap_width(\"bitmap\"), 1 + rnd() * 50, opts);\n            fill_circle(random_rgb_color(128), rnd() * bitmap_width(bmp), rnd() * bitmap_width(bmp), 1 + rnd() * 50, opts);\n        }\n        else\n        {\n            circle c;\n            c = circle_at(rnd() * bitmap_width(bmp), rnd() * bitmap_height(bmp), 1 + rnd() * 50);\n            draw_circle(random_rgb_color(128), c, opts);\n            \n            c = circle_at(rnd() * bitmap_width(bmp), rnd() * bitmap_height(bmp), 1 + rnd() * 50);\n            fill_circle(random_rgb_color(128), c, opts);\n        }\n        \n        draw_bitmap(bmp, 150, 150);\n        \n        refresh_screen();\n    }\n    cout << \"Saving circles bitmap to desktop\" << endl;\n    save_bitmap(bmp, \"circle bitmap\");\n    \n    free_bitmap(bmp);\n    free_timer(t);\n}\n\nvoid test_triangle_drawing(window w1)\n{\n    timer t = create_timer(\"shape drawing timer\");\n    start_timer(t);\n    \n    clear_screen(COLOR_WHITE);\n    draw_text(\"Drawing Triangles\", COLOR_TOMATO, \"myfont\", 18, 30, 30);\n    \n    while( not window_close_requested(w1) and timer_ticks(t) < 3000 )\n    {\n        process_events();\n        \n        if ( timer_ticks(t) < 1500)\n            draw_triangle(random_rgb_color(128),\n                          rnd() * screen_width(), rnd() * screen_height(),\n                          rnd() * screen_width(), rnd() * screen_height(),\n                          rnd() * screen_width(), rnd() * screen_height());\n        else\n        {\n            triangle tri = triangle_from(rnd() * screen_width(), rnd() * screen_height(),\n                                         rnd() * screen_width(), rnd() * screen_height(),\n                                         rnd() * screen_width(), rnd() * screen_height());\n            draw_triangle(random_rgb_color(128), tri);\n        }\n        \n        refresh_screen();\n    }\n    reset_timer(t);\n    clear_screen(COLOR_WHITE);\n    draw_text(\"Filling Triangles\", COLOR_TOMATO, \"myfont\", 18, 30, 30);\n    \n    while( not window_close_requested(w1) and timer_ticks(t) < 3000 )\n    {\n        process_events();\n        \n        if ( timer_ticks(t) < 1500)\n            fill_triangle(random_rgb_color(128),\n                          rnd() * screen_width(), rnd() * screen_height(),\n                          rnd() * screen_width(), rnd() * screen_height(),\n                          rnd() * screen_width(), rnd() * screen_height());\n        else\n        {\n            triangle tri = triangle_from(rnd() * screen_width(), rnd() * screen_height(),\n                                         rnd() * screen_width(), rnd() * screen_height(),\n                                         rnd() * screen_width(), rnd() * screen_height());\n            fill_triangle(random_rgb_color(128), tri);\n        }\n        \n        refresh_screen();\n    }\n    \n    reset_timer(t);\n    clear_screen(COLOR_WHITE);\n    draw_text(\"Draw Triangles to Bitmap\", COLOR_TOMATO, \"myfont\", 18, 30, 30);\n    \n    bitmap bmp = create_bitmap(\"bitmap\", 300, 300);\n    drawing_options opts = option_draw_to(bmp);\n    \n    clear_bitmap(bmp, COLOR_WHEAT);\n    \n    while( not window_close_requested(w1) and timer_ticks(t) < 3000 )\n    {\n        process_events();\n        \n        if ( timer_ticks(t) < 1500)\n        {\n            draw_triangle(random_rgb_color(128),\n                          rnd() * bitmap_width(bmp), rnd() * bitmap_height(bmp),\n                          rnd() * bitmap_width(bmp), rnd() * bitmap_height(bmp),\n                          rnd() * bitmap_width(bmp), rnd() * bitmap_height(bmp),\n                          opts);\n            fill_triangle(random_rgb_color(128),\n                          rnd() * bitmap_width(bmp), rnd() * bitmap_height(bmp),\n                          rnd() * bitmap_width(bmp), rnd() * bitmap_height(bmp),\n                          rnd() * bitmap_width(bmp), rnd() * bitmap_height(bmp),\n                          opts);\n        }\n        else\n        {\n            triangle tri = triangle_from(rnd() * bitmap_width(bmp), rnd() * bitmap_height(bmp),\n                                         rnd() * bitmap_width(bmp), rnd() * bitmap_height(bmp),\n                                         rnd() * bitmap_width(bmp), rnd() * bitmap_height(bmp));\n            fill_triangle(random_rgb_color(128), tri, opts);\n            \n            tri = triangle_from(rnd() * bitmap_width(bmp), rnd() * bitmap_height(bmp),\n                                rnd() * bitmap_width(bmp), rnd() * bitmap_height(bmp),\n                                rnd() * bitmap_width(bmp), rnd() * bitmap_height(bmp));\n            draw_triangle(random_rgb_color(128), tri, opts);\n        }\n        \n        draw_bitmap(bmp, 150, 150);\n        \n        refresh_screen();\n    }\n    \n    free_bitmap(bmp);\n    free_timer(t);\n}\n\nvoid test_quad_drawing(window w1)\n{\n    timer t = create_timer(\"shape drawing timer\");\n    start_timer(t);\n    \n    clear_screen(COLOR_WHITE);\n    draw_text(\"Drawing Quads\", COLOR_TOMATO, \"myfont\", 18, 30, 30);\n    \n    point_2d tl;\n    quad q;\n    \n    while( not window_close_requested(w1) and timer_ticks(t) < 3000 )\n    {\n        process_events();\n        \n        tl = random_screen_point();\n        q = quad_from(tl, point_at(tl.x + 100, tl.y + 25), point_at(tl.x + 25, tl.y + 100), point_at(tl.x + 125, tl.y + 125));\n        \n        if ( timer_ticks(t) < 1500)\n            draw_quad(random_rgb_color(128), q);\n        else\n        {\n            fill_quad(random_rgb_color(128), q);\n        }\n        \n        refresh_screen();\n    }\n    \n    reset_timer(t);\n    clear_screen(COLOR_WHITE);\n    draw_text(\"Draw Triangles to Bitmap\", COLOR_TOMATO, \"myfont\", 18, 30, 30);\n    \n    bitmap bmp = create_bitmap(\"bitmap\", 300, 300);\n    drawing_options opts = option_draw_to(bmp);\n    \n    clear_bitmap(bmp, COLOR_WHEAT);\n    \n    while( not window_close_requested(w1) and timer_ticks(t) < 3000 )\n    {\n        process_events();\n        \n        tl = random_screen_point();\n        q = quad_from(tl, point_at(tl.x + 100, tl.y + 25), point_at(tl.x + 25, tl.y + 100), point_at(tl.x + 125, tl.y + 125));\n\n        \n        if ( timer_ticks(t) < 1500)\n        {\n            draw_quad(random_rgb_color(128), q, opts);\n        }\n        else\n        {\n            fill_quad(random_rgb_color(128), q, opts);\n        }\n        \n        draw_bitmap(bmp, 150, 150);\n        \n        refresh_screen();\n    }\n    \n    free_bitmap(bmp);\n    free_timer(t);\n}\n\nvoid test_aa_rect_drawing(window w1)\n{\n    timer t = create_timer(\"shape drawing timer\");\n    start_timer(t);\n    \n    clear_screen(COLOR_WHITE);\n    draw_text(\"Drawing Rectangles\", COLOR_TOMATO, \"myfont\", 18, 30, 30);\n    \n    while( not window_close_requested(w1) and timer_ticks(t) < 3000 )\n    {\n        process_events();\n        \n        if ( timer_ticks(t) < 1500)\n            draw_rectangle(random_rgb_color(128), rnd() * screen_width() - 100, rnd() * screen_height() - 100, 1 + rnd() * 200, 1 + rnd() * 200);\n        else\n        {\n            rectangle r = rectangle_from(rnd() * window_width(w1) - 100, rnd() * window_height(\"Test Shape Drawing\") - 100, 1 + rnd() * 200, 1 + rnd() * 200);\n            draw_rectangle(random_rgb_color(128), r);\n        }\n        \n        refresh_screen();\n    }\n    reset_timer(t);\n    clear_screen(COLOR_WHITE);\n    draw_text(\"Filling Rectangles\", COLOR_TOMATO, \"myfont\", 18, 30, 30);\n    \n    while( not window_close_requested(w1) and timer_ticks(t) < 3000 )\n    {\n        process_events();\n        \n        if ( timer_ticks(t) < 1500)\n            fill_rectangle(random_rgb_color(128), rnd() * screen_width() - 100, rnd() * screen_height() - 100, 1 + rnd() * 200, 1 + rnd() * 200);\n        else\n        {\n            rectangle r = rectangle_from(rnd() * window_width(w1) - 100, rnd() * window_height(\"Test Shape Drawing\") - 100, 1 + rnd() * 200, 1 + rnd() * 200);\n            fill_rectangle(random_rgb_color(128), r);\n        }\n        \n        refresh_screen();\n    }\n    \n    reset_timer(t);\n    clear_screen(COLOR_WHITE);\n    draw_text(\"Draw Rectangles to Bitmap\", COLOR_TOMATO, \"myfont\", 18, 30, 30);\n    \n    bitmap bmp = create_bitmap(\"bitmap\", 300, 300);\n    drawing_options opts = option_draw_to(bmp);\n    \n    clear_bitmap(bmp, COLOR_WHEAT);\n    \n    while( not window_close_requested(w1) and timer_ticks(t) < 3000 )\n    {\n        process_events();\n        \n        if ( timer_ticks(t) < 1500)\n        {\n            draw_rectangle(random_rgb_color(128), rnd() * screen_width() - 100, rnd() * screen_height() - 100, 1 + rnd() * 200, 1 + rnd() * 200, opts);\n            fill_rectangle(random_rgb_color(128), rnd() * screen_width() - 100, rnd() * screen_height() - 100, 1 + rnd() * 200, 1 + rnd() * 200, opts);\n        }\n        else\n        {\n            rectangle r = rectangle_from(rnd() * window_width(w1) - 100, rnd() * window_height(\"Test Shape Drawing\") - 100, 1 + rnd() * 200, 1 + rnd() * 200);\n            draw_rectangle(random_rgb_color(128), r, opts);\n            \n            r = rectangle_from(rnd() * window_width(w1) - 100, rnd() * window_height(\"Test Shape Drawing\") - 100, 1 + rnd() * 200, 1 + rnd() * 200);\n            fill_rectangle(random_rgb_color(128), r, opts);\n        }\n        \n        draw_bitmap(bmp, 150, 150);\n        \n        refresh_screen();\n    }\n    \n    free_bitmap(bmp);\n    free_timer(t);\n}\n\nvoid test_ellipse_drawing(window w1)\n{\n    timer t = create_timer(\"shape drawing timer\");\n    start_timer(t);\n    \n    clear_screen(COLOR_WHITE);\n    draw_text(\"Drawing Ellipse\", COLOR_TOMATO, \"myfont\", 18, 30, 30);\n    \n    while( not window_close_requested(w1) and timer_ticks(t) < 3000 )\n    {\n        process_events();\n        \n        if ( timer_ticks(t) < 1500)\n            draw_ellipse(random_rgb_color(128), rnd() * screen_width() - 100, rnd() * screen_height() - 100, 1 + rnd() * 200, 1 + rnd() * 200);\n        else\n        {\n            rectangle r = rectangle_from(rnd() * window_width(w1) - 100, rnd() * window_height(\"Test Shape Drawing\") - 100, 1 + rnd() * 200, 1 + rnd() * 200);\n            draw_ellipse(random_rgb_color(128), r);\n        }\n        \n        refresh_screen();\n    }\n    reset_timer(t);\n    clear_screen(COLOR_WHITE);\n    draw_text(\"Filling Ellipses\", COLOR_TOMATO, \"myfont\", 18, 30, 30);\n    \n    while( not window_close_requested(w1) and timer_ticks(t) < 3000 )\n    {\n        process_events();\n        \n        if ( timer_ticks(t) < 1500)\n            fill_ellipse(random_rgb_color(128), rnd() * screen_width() - 100, rnd() * screen_height() - 100, 1 + rnd() * 200, 1 + rnd() * 200);\n        else\n        {\n            rectangle r = rectangle_from(rnd() * window_width(w1) - 100, rnd() * window_height(\"Test Shape Drawing\") - 100, 1 + rnd() * 200, 1 + rnd() * 200);\n            fill_ellipse(random_rgb_color(128), r);\n        }\n        \n        refresh_screen();\n    }\n    \n    reset_timer(t);\n    clear_screen(COLOR_WHITE);\n    draw_text(\"Draw Ellipses to Bitmap\", COLOR_TOMATO, \"myfont\", 18, 30, 30);\n    \n    bitmap bmp = create_bitmap(\"bitmap\", 300, 300);\n    drawing_options opts = option_draw_to(bmp);\n    \n    clear_bitmap(bmp, COLOR_WHEAT);\n    \n    while( not window_close_requested(w1) and timer_ticks(t) < 3000 )\n    {\n        process_events();\n        \n        if ( timer_ticks(t) < 1500)\n        {\n            draw_ellipse(random_rgb_color(128), rnd() * screen_width() - 100, rnd() * screen_height() - 100, 1 + rnd() * 200, 1 + rnd() * 200, opts);\n            fill_ellipse(random_rgb_color(128), rnd() * screen_width() - 100, rnd() * screen_height() - 100, 1 + rnd() * 200, 1 + rnd() * 200, opts);\n        }\n        else\n        {\n            rectangle r = rectangle_from(rnd() * window_width(w1) - 100, rnd() * window_height(\"Test Shape Drawing\") - 100, 1 + rnd() * 200, 1 + rnd() * 200);\n            draw_ellipse(random_rgb_color(128), r, opts);\n            \n            r = rectangle_from(rnd() * window_width(w1) - 100, rnd() * window_height(\"Test Shape Drawing\") - 100, 1 + rnd() * 200, 1 + rnd() * 200);\n            fill_ellipse(random_rgb_color(128), r, opts);\n        }\n        \n        draw_bitmap(bmp, 150, 150);\n        \n        refresh_screen();\n    }\n    \n    free_bitmap(bmp);\n    free_timer(t);\n}\n\nvoid test_line_drawing(window w1)\n{\n    timer t = create_timer(\"shape drawing timer\");\n    start_timer(t);\n    \n    clear_screen(COLOR_WHITE);\n    draw_text(\"Drawing Lines\", COLOR_TOMATO, \"myfont\", 18, 30, 30);\n    \n    while( not window_close_requested(w1) and timer_ticks(t) < 3000 )\n    {\n        process_events();\n        \n        if ( timer_ticks(t) < 1500)\n            draw_line(random_rgb_color(128), rnd() * screen_width(), rnd() * screen_height(), rnd() * screen_width(), rnd() * screen_height());\n        else\n            draw_line(random_rgb_color(128), line_from(random_screen_point(), random_screen_point()));\n        \n        refresh_screen();\n    }\n    \n    reset_timer(t);\n    clear_screen(COLOR_WHITE);\n    draw_text(\"Draw Lines to Bitmap\", COLOR_TOMATO, \"myfont\", 18, 30, 30);\n    \n    bitmap bmp = create_bitmap(\"bitmap\", 300, 300);\n    drawing_options opts = option_draw_to(bmp);\n    \n    clear_bitmap(bmp, COLOR_WHEAT);\n    \n    while( not window_close_requested(w1) and timer_ticks(t) < 3000 )\n    {\n        process_events();\n        \n        opts.line_width = rnd(5) + 1;\n        \n        if ( timer_ticks(t) < 1500)\n        {\n            draw_line(random_rgb_color(128), rnd() * bitmap_width(bmp), rnd() * bitmap_height(bmp), rnd() * bitmap_width(bmp), rnd() * bitmap_height(bmp), opts);\n        }\n        else\n        {\n            draw_line(random_rgb_color(128), line_from(random_bitmap_point(bmp), random_bitmap_point(bmp)), opts);\n        }\n        \n        draw_bitmap(bmp, 150, 150);\n        \n        refresh_screen();\n    }\n    \n    free_bitmap(bmp);\n    free_timer(t);\n}\n\n\nvoid run_shape_drawing_test()\n{\n    window w1 = open_window(\"Test Shape Drawing\", 600, 600);\n    \n    load_font(\"myfont\", \"hara.ttf\");\n    \n    test_circle_drawing(w1);\n    test_aa_rect_drawing(w1);\n    test_triangle_drawing(w1);\n    test_quad_drawing(w1);\n    test_ellipse_drawing(w1);\n    test_line_drawing(w1);\n    \n    close_window(w1);\n}",
  "tests": [
    {
      "description": "Returns the center point of the circle.",
      "name": "center_point",
      "return_description": "The center point of the circle",
      "signature": "point_2d center_point(const circle &c);",
      "unique_global_name": "center_point"
    },
    {
      "description": "Returns a circle at the indicated point and radius.",
      "name": "circle_at",
      "return_description": "A circle at the indicatd point and radius",
      "signature": "circle circle_at(const point_2d &pt,double radius);",
      "unique_global_name": "circle_at"
    },
    {
      "description": "Returns a circle at the indicated point and radius.",
      "name": "circle_at",
      "return_description": "A circle at the indicatd point and radius",
      "signature": "circle circle_at(double x,double y,double radius);",
      "unique_global_name": "circle_at_from_points"
    },
    {
      "description": "Returns the circle radius.",
      "name": "circle_radius",
      "return_description": "The radius of the circle",
      "signature": "float circle_radius(const circle c);",
      "unique_global_name": "circle_radius"
    },
    {
      "description": "Detects if a circle intersects with a triangle.",
      "name": "circle_triangle_intersect",
      "return_description": "True if the circle and triangle intersect",
      "signature": "bool circle_triangle_intersect(const circle &c,const triangle &tri);",
      "unique_global_name": "circle_triangle_intersect"
    },
    {
      "description": "Detects if a circle intersects with a triangle. The closest point on the\ntriangle to the circle is assigned to p, even if the circle and triangle do not\nintersect. If the centre of the circle is inside the triangle,\nthe point assigned to p is the centre of the circle.",
      "name": "circle_triangle_intersect",
      "return_description": "True if the circle and triangle intersect",
      "signature": "bool circle_triangle_intersect(const circle &c,const triangle &tri,point_2d &p);",
      "unique_global_name": "circle_triangle_intersect_get_closest_point"
    },
    {
      "description": "Returns the circle x value.",
      "name": "circle_x",
      "return_description": "The x location of the center of the circle",
      "signature": "float circle_x(const circle &c);",
      "unique_global_name": "circle_x"
    },
    {
      "description": "Returns the circle y value.",
      "name": "circle_y",
      "return_description": "The y location of the center of the circle",
      "signature": "float circle_y(const circle &c);",
      "unique_global_name": "circle_y"
    },
    {
      "description": "Detects if two circles intersect. This can be used to detect collisions between\nbounding circles.",
      "name": "circles_intersect",
      "return_description": "True if the two circles do intersect",
      "signature": "bool circles_intersect(circle c1,circle c2);",
      "unique_global_name": "circles_intersect"
    },
    {
      "description": "Detects if two circles intersect. This can be used to detect collisions between\nbounding circles. The circle data is passed in as individual values.",
      "name": "circles_intersect",
      "return_description": "true when the two circles intersect",
      "signature": "bool circles_intersect(double c1_x,double c1_y,double c1_radius,double c2_x,double c2_y,double c2_radius);",
      "unique_global_name": "circles_intersect_using_values"
    },
    {
      "description": "The closest point on the circle to the given point.",
      "name": "closest_point_on_circle",
      "return_description": "The point on c that is closest to the from point",
      "signature": "point_2d closest_point_on_circle(const point_2d &from_pt,const circle &c);",
      "unique_global_name": "closest_point_on_circle"
    },
    {
      "description": "Returns the closest point on a line to a circle.",
      "name": "closest_point_on_line_from_circle",
      "return_description": "The point that is closest to `c` on `l`",
      "signature": "point_2d closest_point_on_line_from_circle(const circle &c,const line &l);",
      "unique_global_name": "closest_point_on_line_from_circle"
    },
    {
      "description": "Returns the closest point on a rectangle to a circle.",
      "name": "closest_point_on_rect_from_circle",
      "return_description": "The point that is closest to `c` on `rect`",
      "signature": "point_2d closest_point_on_rect_from_circle(const circle &c,const rectangle &rect);",
      "unique_global_name": "closest_point_on_rect_from_circle"
    },
    {
      "description": "Calculates the closest point on a triangle to a circle. If the circle and\ntriangle do not intersect, the closest point on the triangle to the circle\nis returned. If the circle and triangle do intersect, the center of the\ncircle is returned.",
      "name": "closest_point_on_triangle_from_circle",
      "return_description": "The closest point on the triangle to the circle",
      "signature": "point_2d closest_point_on_triangle_from_circle(const circle &c,const triangle &tri);",
      "unique_global_name": "closest_point_on_triangle_from_circle"
    },
    {
      "description": "The furthest point on the circle to the given point.",
      "name": "distant_point_on_circle",
      "return_description": "The point on c that is furthest from `pt`",
      "signature": "point_2d distant_point_on_circle(const point_2d &pt,const circle &c);",
      "unique_global_name": "distant_point_on_circle"
    },
    {
      "description": "Determines the opposite side of a circle given a collision point and a\nheading.",
      "name": "distant_point_on_circle_heading",
      "return_description": "True when the `opposite_pt` is calculated, false when\nthe point would not collide with the circle when\nheading as indicated.",
      "signature": "bool distant_point_on_circle_heading(const point_2d &pt,const circle &c,const vector_2d &heading,point_2d &opposite_pt);",
      "unique_global_name": "distant_point_on_circle_heading"
    },
    {
      "description": "Calculates the distance from a ray cast from a point to a given circle.",
      "name": "ray_circle_intersect_distance",
      "return_description": "-1 if the ray does not hit the circle, otherwise the\ndistance from the origin to the circle bounds.",
      "signature": "float ray_circle_intersect_distance(const point_2d &ray_origin,const vector_2d &ray_heading,const circle &c);",
      "unique_global_name": "ray_circle_intersect_distance"
    },
    {
      "description": "Returns the two tangent points on the circle given the indicated point.",
      "name": "tangent_points",
      "return_description": "True if `from_pt` is outside of the circle, and tangent\npoints are calculated",
      "signature": "bool tangent_points(const point_2d &from_pt,const circle &c,point_2d &p1,point_2d &p2);",
      "unique_global_name": "tangent_points"
    },
    {
      "description": "Calculates the two points on a circles radius that lie along the given\nvector. This represents the points on the circle when the vector is\nplaced at the circle's center point.",
      "name": "widest_points",
      "return_description": null,
      "signature": "void widest_points(const circle &c,const vector_2d &along,point_2d &pt1,point_2d &pt2);",
      "unique_global_name": "widest_points"
    },
    {
      "description": "Returns the cosine of the supplied angle (in degrees).",
      "name": "cosine",
      "return_description": "the cosine of the supplied angle (in degrees).",
      "signature": "float cosine(float degrees);",
      "unique_global_name": "cosine"
    },
    {
      "description": "Returns the sine of the supplied angle (in degrees).",
      "name": "sine",
      "return_description": "the sine of the supplied angle (in degrees).",
      "signature": "float sine(float degrees);",
      "unique_global_name": "sine"
    },
    {
      "description": "Returns the tangent of the supplied angle (in degrees).",
      "name": "tangent",
      "return_description": "the tangent of the supplied angle (in degrees).",
      "signature": "float tangent(float degrees);",
      "unique_global_name": "tangent"
    },
    {
      "description": "Gets the closest point on the line to a given point.",
      "name": "closest_point_on_line",
      "return_description": "The point on the line that is closest to `from_pt`",
      "signature": "point_2d closest_point_on_line(const point_2d from_pt,const line &l);",
      "unique_global_name": "closest_point_on_line"
    },
    {
      "description": "Get the point closest to `from pt` that is on one of the supplied lines.",
      "name": "closest_point_on_lines",
      "return_description": "The point on one of the lines that is the closest point\non these lines to the `from pt`.",
      "signature": "point_2d closest_point_on_lines(const point_2d from_pt,const vector<line> &lines,int &line_idx);",
      "unique_global_name": "closest_point_on_lines"
    },
    {
      "description": "Create a line from one point to another.",
      "name": "line_from",
      "return_description": "A line from the start to the end point",
      "signature": "line line_from(const point_2d &start,const point_2d &end_pt);",
      "unique_global_name": "line_from_point_to_point"
    },
    {
      "description": "Creates a line that starts at a point, and follows a given vector.",
      "name": "line_from",
      "return_description": "A line from the start to end point",
      "signature": "line line_from(const point_2d &start,const vector_2d &offset);",
      "unique_global_name": "line_from_start_with_offset"
    },
    {
      "description": "Gets a line that goes from the origin and ends at the end of the vector.",
      "name": "line_from",
      "return_description": "A line from the origin to the end point",
      "signature": "line line_from(const vector_2d &v);",
      "unique_global_name": "line_from_vector"
    },
    {
      "description": "Create a line from one point to another.",
      "name": "line_from",
      "return_description": "A line from the start to the end point",
      "signature": "line line_from(double x1,double y1,double x2,double y2);",
      "unique_global_name": "line_from"
    },
    {
      "description": "Returns the point at which two lines would intersect. This point may lie\npast the end of one or both lines.",
      "name": "line_intersection_point",
      "return_description": "[description]",
      "signature": "bool line_intersection_point(const line &line1,const line &line2,point_2d &pt);",
      "unique_global_name": "line_intersection_point"
    },
    {
      "description": "Returns true if the line intersects the circle.",
      "name": "line_intersects_circle",
      "return_description": "True if the line `l` intersects the circle `c`",
      "signature": "bool line_intersects_circle(const line &l,const circle &c);",
      "unique_global_name": "line_intersects_circle"
    },
    {
      "description": "Returns true if the line intersects any of the lines.",
      "name": "line_intersects_lines",
      "return_description": "True if `line` intersects any of the lines in `lines`",
      "signature": "bool line_intersects_lines(const line &l,const vector<line> &lines);",
      "unique_global_name": "line_intersects_lines"
    },
    {
      "description": "Returns true if the line intersects the rectangle.",
      "name": "line_intersects_rect",
      "return_description": "True if `l` intersects `rect`",
      "signature": "bool line_intersects_rect(const line &l,const rectangle &rect);",
      "unique_global_name": "line_intersects_rect"
    },
    {
      "description": "Returns the length of a line.",
      "name": "line_length",
      "return_description": "The length of the line",
      "signature": "float line_length(const line &l);",
      "unique_global_name": "line_length"
    },
    {
      "description": "Returns the squared length of the line. You can also get the\n`line_length`.",
      "name": "line_length_squared",
      "return_description": "The squared length of the line",
      "signature": "float line_length_squared(const line &l);",
      "unique_global_name": "line_length_squared"
    },
    {
      "description": "Returns the center point of the line.",
      "name": "line_mid_point",
      "return_description": "The point that is at the center of the line",
      "signature": "point_2d line_mid_point(const line &l);",
      "unique_global_name": "line_mid_point"
    },
    {
      "description": "The line normal (a perpendicular vector).",
      "name": "line_normal",
      "return_description": "The line's normal vector",
      "signature": "vector_2d line_normal(const line &l);",
      "unique_global_name": "line_normal"
    },
    {
      "description": "Returns a text description of the line.",
      "name": "line_to_string",
      "return_description": "A text description of the line",
      "signature": "string line_to_string(const line &ln);",
      "unique_global_name": "line_to_string"
    },
    {
      "description": "Returns an array of lines from a supplied rectangle.",
      "name": "lines_from",
      "return_description": "An array containing 4 lines",
      "signature": "vector<line> lines_from(const rectangle &rect);",
      "unique_global_name": "lines_from_rectangle"
    },
    {
      "description": "Returns an array of lines from the details in the triangle.",
      "name": "lines_from",
      "return_description": "The lines from the triangle",
      "signature": "vector<line> lines_from(const triangle &t);",
      "unique_global_name": "lines_from_triangle"
    },
    {
      "description": "Returns true if the two lines intersect.",
      "name": "lines_intersect",
      "return_description": "True if the two lines intersect (share a common point).",
      "signature": "bool lines_intersect(const line &l1,const line &l2);",
      "unique_global_name": "lines_intersect"
    },
    {
      "description": "Returns a point at the given location.",
      "name": "point_at",
      "return_description": "A point at the given location",
      "signature": "point_2d point_at(double x,double y);",
      "unique_global_name": "point_at"
    },
    {
      "description": "Returns a point representing the origin.",
      "name": "point_at_origin",
      "return_description": "A point with x and y set to 0",
      "signature": "point_2d point_at_origin();",
      "unique_global_name": "point_at_origin"
    },
    {
      "description": "Returns true if the point `pt` is in the circle `c`.",
      "name": "point_in_circle",
      "return_description": "True if the point is within the area of the circle",
      "signature": "bool point_in_circle(const point_2d &pt,const circle &c);",
      "unique_global_name": "point_in_circle"
    },
    {
      "description": "Return true if the point is in the circle.",
      "name": "point_in_circle",
      "return_description": "True when the point is in the circle, otherwise it returns false.",
      "signature": "bool point_in_circle(double ptx,double pty,double cx,double cy,double radius);",
      "unique_global_name": "point_in_circle_with_values"
    },
    {
      "description": "Tests if a point is in a quad.",
      "name": "point_in_quad",
      "return_description": "True if pt lies within the area of q.",
      "signature": "bool point_in_quad(const point_2d &pt,const quad &q);",
      "unique_global_name": "point_in_quad"
    },
    {
      "description": "Returns true if point `pt` is in the Rectangle `rect`.",
      "name": "point_in_rectangle",
      "return_description": "True if the point is within the rectangle",
      "signature": "bool point_in_rectangle(const point_2d &pt,const rectangle &rect);",
      "unique_global_name": "point_in_rectangle"
    },
    {
      "description": "Returns true if the point is within the bounds of a Rectangle.",
      "name": "point_in_rectangle",
      "return_description": "true when the point is in the rectangle, otherwise it returns false.",
      "signature": "bool point_in_rectangle(double ptx,double pty,double rect_x,double rect_y,double rect_width,double rect_height);",
      "unique_global_name": "point_in_rectangle_with_values"
    },
    {
      "description": "Returns true if the point `pt` is in the Triangle `tri`.",
      "name": "point_in_triangle",
      "return_description": "True if the point is within the triangle",
      "signature": "bool point_in_triangle(const point_2d &pt,const triangle &tri);",
      "unique_global_name": "point_in_triangle"
    },
    {
      "description": "Returns the distance from a point to a line.",
      "name": "point_line_distance",
      "return_description": "The distance from `pt` to `l`",
      "signature": "float point_line_distance(const point_2d &pt,const line &l);",
      "unique_global_name": "point_line_distance"
    },
    {
      "description": "Calculate the `point_2d` that is offset from the `start_point` by the\n`offset`",
      "name": "point_offset_by",
      "return_description": "A new point as a result of moving by the offset from\nthe starting point",
      "signature": "point_2d point_offset_by(const point_2d &start_point,const vector_2d &offset);",
      "unique_global_name": "point_offset_by"
    },
    {
      "description": "Returns the point offset from the origin by the provided vector.",
      "name": "point_offset_from_origin",
      "return_description": "A new point as a result of moving by the offset from\nthe starting point",
      "signature": "point_2d point_offset_from_origin(const vector_2d &offset);",
      "unique_global_name": "point_offset_from_origin"
    },
    {
      "description": "Returns true if point `pt` is on the line `l`.",
      "name": "point_on_line",
      "return_description": "True if the point is on the line",
      "signature": "bool point_on_line(const point_2d &pt,const line &l);",
      "unique_global_name": "point_on_line"
    },
    {
      "description": "Returns true when the point `pt` is on the line `l`. The\nproximity value is used to set the sensitivity -- higher values\neffectively make the line thicker.",
      "name": "point_on_line",
      "return_description": "True if the point is on the line",
      "signature": "bool point_on_line(const point_2d &pt,const line &l,float proximity);",
      "unique_global_name": "point_on_line_with_proximity"
    },
    {
      "description": "Returns the angle between two points in degrees.",
      "name": "point_point_angle",
      "return_description": "The angle (in degrees) of the line between the points",
      "signature": "float point_point_angle(const point_2d &pt1,const point_2d &pt2);",
      "unique_global_name": "point_point_angle"
    },
    {
      "description": "Returns the distance between two points.",
      "name": "point_point_distance",
      "return_description": "The distance between the two points",
      "signature": "float point_point_distance(const point_2d &pt1,const point_2d &pt2);",
      "unique_global_name": "point_point_distance"
    },
    {
      "description": "Get a text description of the `point_2d`.",
      "name": "point_to_string",
      "return_description": "A string representation of the point",
      "signature": "string point_to_string(const point_2d &pt);",
      "unique_global_name": "point_to_string"
    },
    {
      "description": "Returns a random point within the bounds of the bitmap.",
      "name": "random_bitmap_point",
      "return_description": "A point within the bounds of the bitmap",
      "signature": "point_2d random_bitmap_point(bitmap bmp);",
      "unique_global_name": "random_bitmap_point"
    },
    {
      "description": "Returns a random point on the current window.",
      "name": "random_screen_point",
      "return_description": "A point within the bounds of the current window",
      "signature": "point_2d random_screen_point();",
      "unique_global_name": "random_screen_point"
    },
    {
      "description": "Returns a random point on the provided window.",
      "name": "random_window_point",
      "return_description": "A point within the bounds of the window",
      "signature": "point_2d random_window_point(window wind);",
      "unique_global_name": "random_window_point"
    },
    {
      "description": "Returns True of `pt1` is at the same point as `pt2`. This checks at an\ninteger level, indicating the two points refer to the same pixel.",
      "name": "same_point",
      "return_description": "True if the two points are at the same location",
      "signature": "bool same_point(const point_2d &pt1,const point_2d &pt2);",
      "unique_global_name": "same_point"
    },
    {
      "description": "Returns a quad from the passed in points.",
      "name": "quad_from",
      "return_description": "A quad from the passed in points",
      "signature": "quad quad_from(const point_2d &p1,const point_2d &p2,const point_2d &p3,const point_2d &p4);",
      "unique_global_name": "quad_from_points"
    },
    {
      "description": "Returns a quad from the x-y points of a given recatangle",
      "name": "quad_from",
      "return_description": "A quad at the same location as the rectangle",
      "signature": "quad quad_from(const rectangle &rect);",
      "unique_global_name": "quad_from_rectangle"
    },
    {
      "description": "Returns a quad from the rectangle, then applies the transformation to\nthe quads points.",
      "name": "quad_from",
      "return_description": "A quad that represents the rectangle after the transformation.",
      "signature": "quad quad_from(const rectangle &rect,const matrix_2d &transform);",
      "unique_global_name": "quad_from_rectangle_with_transformation"
    },
    {
      "description": "Returns a quad for the passed in x & y points.",
      "name": "quad_from",
      "return_description": "A quad with the indicated points",
      "signature": "quad quad_from(double x_top_left,double y_top_left,double x_top_right,double y_top_right,double x_bottom_left,double y_bottom_left,double x_bottom_right,double y_bottom_right );",
      "unique_global_name": "quad_from"
    },
    {
      "description": "Returns true if two quads intersect.",
      "name": "quads_intersect",
      "return_description": "True if the two quads intersect.",
      "signature": "bool quads_intersect(const quad &q1,const quad &q2);",
      "unique_global_name": "quads_intersect"
    },
    {
      "description": "Change a point in a quad.",
      "name": "set_quad_point",
      "return_description": null,
      "signature": "void set_quad_point(quad &q,int idx,const point_2d &value);",
      "unique_global_name": "set_quad_point"
    },
    {
      "description": "Returns the two triangles that make up a quad in a vector.",
      "name": "triangles_from",
      "return_description": "A vector with the two triangles from the quad.",
      "signature": "vector<triangle> triangles_from(const quad &q);",
      "unique_global_name": "triangles_from"
    },
    {
      "description": "Return a rectangle that is inset an amount from a given rectangle.",
      "name": "inset_rectangle",
      "return_description": "A new rectangle created inset from `rect`",
      "signature": "rectangle inset_rectangle(const rectangle &rect,float inset_amount);",
      "unique_global_name": "inset_rectangle"
    },
    {
      "description": "Returns a rectangle that represents the intersection of two rectangles.",
      "name": "intersection",
      "return_description": "The intersection of rect1 and rect2.",
      "signature": "rectangle intersection(const rectangle &rect1,const rectangle &rect2);",
      "unique_global_name": "intersection"
    },
    {
      "description": "Returns a rectangle that surrounds a given circle",
      "name": "rectangle_around",
      "return_description": "A rectangle that will surround the circle",
      "signature": "rectangle rectangle_around(const circle &c);",
      "unique_global_name": "rectangle_around_circle"
    },
    {
      "description": "Returns a rectangle that surrounds a given line segment",
      "name": "rectangle_around",
      "return_description": "A rectangle that will surround the line",
      "signature": "rectangle rectangle_around(const line &l);",
      "unique_global_name": "rectangle_around_line"
    },
    {
      "description": "Returns a rectangle that surrounds a given quad.",
      "name": "rectangle_around",
      "return_description": "A rectangle that will surround the quad",
      "signature": "rectangle rectangle_around(const quad &q);",
      "unique_global_name": "rectangle_around_quad"
    },
    {
      "description": "Returns a rectangle that surrounds a given triangle",
      "name": "rectangle_around",
      "return_description": "A rectangle that will surround the triangle",
      "signature": "rectangle rectangle_around(const triangle &t);",
      "unique_global_name": "rectangle_around_triangle"
    },
    {
      "description": "The location of the bottom of the rectangle.",
      "name": "rectangle_bottom",
      "return_description": "The distance from the top of the screen to the bottom of\nthe rectangle.",
      "signature": "float rectangle_bottom(const rectangle &rect);",
      "unique_global_name": "rectangle_bottom"
    },
    {
      "description": "Returns the center point of a given rectangle",
      "name": "rectangle_center",
      "return_description": "The center point of the vector",
      "signature": "point_2d rectangle_center(const rectangle &rect);",
      "unique_global_name": "rectangle_center"
    },
    {
      "description": "Returns a rectangle at the specified point with a given width and height",
      "name": "rectangle_from",
      "return_description": "A rectangle with the specified dimensions and location",
      "signature": "rectangle rectangle_from(const point_2d pt,const double width,const double height);",
      "unique_global_name": "rectangle_from_point_and_size"
    },
    {
      "description": "Returns a rectangle with pt1 and pt2 defining the two distant edge points.",
      "name": "rectangle_from",
      "return_description": "A rectangle enclosing the two points.",
      "signature": "rectangle rectangle_from(const point_2d pt1,const point_2d pt2);",
      "unique_global_name": "rectangle_from_points"
    },
    {
      "description": "Returns a rectangle from a given x,y location with the specified width\nand height.",
      "name": "rectangle_from",
      "return_description": "A rectangle with the specified dimensions and location.",
      "signature": "rectangle rectangle_from(double x,double y,double width,double height);",
      "unique_global_name": "rectangle_from"
    },
    {
      "description": "The location of the left edge of the rectangle.",
      "name": "rectangle_left",
      "return_description": "The distance from the left of the screen to the left side of\nthe rectangle.",
      "signature": "float rectangle_left(const rectangle &rect);",
      "unique_global_name": "rectangle_left"
    },
    {
      "description": "Returns a rectangle that is moved by the provided vector.",
      "name": "rectangle_offset_by",
      "return_description": "A new rectangle that represents the original rectangle\nafter being moved by the offset vector.",
      "signature": "rectangle rectangle_offset_by(const rectangle &rect,const vector_2d &offset);",
      "unique_global_name": "rectangle_offset_by"
    },
    {
      "description": "The location of the right edge of the rectangle.",
      "name": "rectangle_right",
      "return_description": "The distance from the left of the screen to the right side\nof the rectangle.",
      "signature": "float rectangle_right(const rectangle &rect);",
      "unique_global_name": "rectangle_right"
    },
    {
      "description": "Get a text representation of the passed in rectangle.",
      "name": "rectangle_to_string",
      "return_description": "A string representation of the rectangle.",
      "signature": "string rectangle_to_string(const rectangle &rect);",
      "unique_global_name": "rectangle_to_string"
    },
    {
      "description": "The top of the rectangle.",
      "name": "rectangle_top",
      "return_description": "Its distance from the top of the screen.",
      "signature": "float rectangle_top(const rectangle &rect);",
      "unique_global_name": "rectangle_top"
    },
    {
      "description": "Returns true if the two rectangles intersect.",
      "name": "rectangles_intersect",
      "return_description": "True when rect1 and rect2 intersect.",
      "signature": "bool rectangles_intersect(const rectangle &rect1,const rectangle &rect2);",
      "unique_global_name": "rectangles_intersect"
    },
    {
      "description": "Return the barycenter of the triangle. This is one way of calculating the\ncenter point of a triangle.",
      "name": "triangle_barycenter",
      "return_description": "The point that is the barycenter of `tri`",
      "signature": "point_2d triangle_barycenter(const triangle &tri);",
      "unique_global_name": "triangle_barycenter"
    },
    {
      "description": "Generate a triangle from a set of points.",
      "name": "triangle_from",
      "return_description": "A triangle with the indicated points",
      "signature": "triangle triangle_from(const point_2d &p1,const point_2d &p2,const point_2d &p3);",
      "unique_global_name": "triangle_from"
    },
    {
      "description": "Generate a triangle from a set of points.",
      "name": "triangle_from",
      "return_description": "A triangle at the indicated points",
      "signature": "triangle triangle_from(double x1,double y1,double x2,double y2,double x3,double y3);",
      "unique_global_name": "triangle_from__from_coordinates"
    },
    {
      "description": "Returns true if the triangle intersects with the rectangle.",
      "name": "triangle_rectangle_intersect",
      "return_description": "True if the triangle and rect intersect",
      "signature": "bool triangle_rectangle_intersect(const triangle &tri,const rectangle &rect);",
      "unique_global_name": "triangle_rectangle_intersect"
    },
    {
      "description": "Returns a text description of the triangle.",
      "name": "triangle_to_string",
      "return_description": "A text description of the triangle.",
      "signature": "string triangle_to_string(const triangle &tri);",
      "unique_global_name": "triangle_to_string"
    },
    {
      "description": "Returns true if the two triangles intersect.",
      "name": "triangles_intersect",
      "return_description": "True if the two triangles intersect",
      "signature": "bool triangles_intersect(const triangle &t1,const triangle &t2);",
      "unique_global_name": "triangles_intersect"
    }
  ]
}
