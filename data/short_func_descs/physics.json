{
  "example": "#include <iostream>\nusing namespace std;\n\n#include \"window_manager.h\"\n#include \"input.h\"\n#include \"physics.h\"\n#include \"graphics.h\"\n\nusing namespace splashkit_lib;\n\nvoid do_test_vector()\n{\n window w1 = open_window(\"Vector Test\", 600, 600);\n \n rectangle r1 = rectangle_from(50, 50, 200, 200), mouse_rect;\n vector_2d v1 = vector_to(0,0);\n circle c = circle_at(300, 300, 50), mouse_circle;\n line l;\n vector_2d velocity = vector_to(10, 0);\n \n bitmap bmp = create_bitmap(\"test\", 100, 100);\n clear_bitmap(bmp, COLOR_RED);\n \n setup_collision_mask(bmp);\n \n while( not window_close_requested(w1))\n {\n mouse_circle = circle_at(mouse_position(), 10);\n mouse_rect = rectangle_from(mouse_x() - 2, mouse_y() - 2, 5, 5);\n \n process_events();\n \n if ( key_down(RIGHT_KEY) )\n {\n velocity = vector_from_angle(vector_angle(velocity) + 1, 10);\n }\n if ( key_down(LEFT_KEY) )\n {\n velocity = vector_from_angle(vector_angle(velocity) - 1, 10);\n }\n \n clear_screen(COLOR_WHITE);\n draw_rectangle(COLOR_GREEN, r1);\n draw_circle(COLOR_GREEN, c);\n draw_bitmap(bmp, 100, 100);\n \n draw_circle(COLOR_RED, mouse_circle);\n draw_rectangle(COLOR_RED, mouse_rect);\n \n if ( point_in_rectangle(mouse_position(), r1))\n {\n v1 = vector_out_of_rect_from_point(mouse_position(), r1, velocity);\n l = line_from(mouse_position(), v1);\n \n draw_line(COLOR_RED, l);\n \n v1 = vector_out_of_rect_from_circle(mouse_circle, r1, velocity);\n draw_circle(COLOR_RED, circle_at(point_offset_by(mouse_position(), v1), 10));\n \n v1 = vector_out_of_rect_from_rect(mouse_rect, r1, velocity);\n draw_rectangle(COLOR_RED, rectangle_offset_by(mouse_rect, v1));\n }\n \n if ( point_in_circle(mouse_position(), c))\n {\n v1 = vector_out_of_circle_from_circle(mouse_circle, c, velocity);\n l = line_from(mouse_position(), v1);\n \n draw_line(COLOR_RED, l);\n draw_circle(COLOR_RED, circle_at(l.end_point, 10));\n }\n \n if ( bitmap_point_collision(bmp, 100, 100, mouse_x(), mouse_y()))\n {\n draw_rectangle(COLOR_BLACK, 100, 100, 100, 100);\n }\n \n refresh_screen();\n }\n \n free_bitmap(bmp);\n close_window(w1);\n}\n\nvoid run_physics_test()\n{\n matrix_2d matrix = identity_matrix();\n matrix_2d inv_matrix = matrix_inverse(matrix);\n \n cout << \"Identity Matrix\" << endl;\n cout << matrix_to_string(matrix) << endl;\n cout << endl << \" inverse \" << endl;\n cout << matrix_to_string(inv_matrix) << endl;\n \n matrix = scale_matrix(4);\n inv_matrix = matrix_inverse(matrix);\n \n cout << \"Scale Matrix - 4x\" << endl;\n cout << matrix_to_string(matrix) << endl;\n cout << endl << \" inverse \" << endl;\n cout << matrix_to_string(inv_matrix) << endl;\n cout << endl << \" check... \" << endl;\n cout << matrix_to_string(matrix_multiply(matrix, inv_matrix)) << endl;\n \n matrix = rotation_matrix(45);\n inv_matrix = matrix_inverse(matrix);\n \n cout << \"Rotation Matrix - 45deg\" << endl;\n cout << matrix_to_string(matrix) << endl;\n cout << endl << \" inverse \" << endl;\n cout << matrix_to_string(inv_matrix) << endl;\n cout << endl << \" check... \" << endl;\n cout << matrix_to_string(matrix_multiply(matrix, inv_matrix)) << endl;\n \n matrix = translation_matrix(100, -100);\n inv_matrix = matrix_inverse(matrix);\n \n cout << \"Translation Matrix - 100,-100\" << endl;\n cout << matrix_to_string(matrix) << endl;\n cout << endl << \" inverse \" << endl;\n cout << matrix_to_string(inv_matrix) << endl;\n cout << endl << \" check... \" << endl;\n cout << matrix_to_string(matrix_multiply(matrix, inv_matrix)) << endl;\n \n cout << \"Rotate 45%\" << endl;\n cout << matrix_to_string(rotation_matrix(45)) << endl;\n \n cout << \"translate 10,10\" << endl;\n cout << matrix_to_string(translation_matrix(10, 10)) << endl;\n \n matrix = matrix_multiply(rotation_matrix(45), translation_matrix(10, 10));\n inv_matrix = matrix_inverse(matrix);\n \n cout << \"Combination\" << endl;\n cout << matrix_to_string(matrix) << endl;\n cout << endl << \" inverse \" << endl;\n cout << matrix_to_string(inv_matrix) << endl;\n cout << endl << \" check... \" << endl;\n cout << matrix_to_string(matrix_multiply(matrix, inv_matrix)) << endl;\n \n do_test_vector();\n}",
  "tests": [
    {
      "description": "Returns the center point of the circle.",
      "name": "center_point",
      "return_description": "The center point of the circle",
      "signature": "point_2d center_point(const circle &c);",
      "unique_global_name": "center_point"
    },
    {
      "description": "Returns a circle at the indicated point and radius.",
      "name": "circle_at",
      "return_description": "A circle at the indicatd point and radius",
      "signature": "circle circle_at(const point_2d &pt,double radius);",
      "unique_global_name": "circle_at"
    },
    {
      "description": "Returns a circle at the indicated point and radius.",
      "name": "circle_at",
      "return_description": "A circle at the indicatd point and radius",
      "signature": "circle circle_at(double x,double y,double radius);",
      "unique_global_name": "circle_at_from_points"
    },
    {
      "description": "Returns the circle radius.",
      "name": "circle_radius",
      "return_description": "The radius of the circle",
      "signature": "float circle_radius(const circle c);",
      "unique_global_name": "circle_radius"
    },
    {
      "description": "Detects if a circle intersects with a triangle.",
      "name": "circle_triangle_intersect",
      "return_description": "True if the circle and triangle intersect",
      "signature": "bool circle_triangle_intersect(const circle &c,const triangle &tri);",
      "unique_global_name": "circle_triangle_intersect"
    },
    {
      "description": "Detects if a circle intersects with a triangle. The closest point on the\ntriangle to the circle is assigned to p, even if the circle and triangle do not\nintersect. If the centre of the circle is inside the triangle,\nthe point assigned to p is the centre of the circle.",
      "name": "circle_triangle_intersect",
      "return_description": "True if the circle and triangle intersect",
      "signature": "bool circle_triangle_intersect(const circle &c,const triangle &tri,point_2d &p);",
      "unique_global_name": "circle_triangle_intersect_get_closest_point"
    },
    {
      "description": "Returns the circle x value.",
      "name": "circle_x",
      "return_description": "The x location of the center of the circle",
      "signature": "float circle_x(const circle &c);",
      "unique_global_name": "circle_x"
    },
    {
      "description": "Returns the circle y value.",
      "name": "circle_y",
      "return_description": "The y location of the center of the circle",
      "signature": "float circle_y(const circle &c);",
      "unique_global_name": "circle_y"
    },
    {
      "description": "Detects if two circles intersect. This can be used to detect collisions between\nbounding circles.",
      "name": "circles_intersect",
      "return_description": "True if the two circles do intersect",
      "signature": "bool circles_intersect(circle c1,circle c2);",
      "unique_global_name": "circles_intersect"
    },
    {
      "description": "Detects if two circles intersect. This can be used to detect collisions between\nbounding circles. The circle data is passed in as individual values.",
      "name": "circles_intersect",
      "return_description": "true when the two circles intersect",
      "signature": "bool circles_intersect(double c1_x,double c1_y,double c1_radius,double c2_x,double c2_y,double c2_radius);",
      "unique_global_name": "circles_intersect_using_values"
    },
    {
      "description": "The closest point on the circle to the given point.",
      "name": "closest_point_on_circle",
      "return_description": "The point on c that is closest to the from point",
      "signature": "point_2d closest_point_on_circle(const point_2d &from_pt,const circle &c);",
      "unique_global_name": "closest_point_on_circle"
    },
    {
      "description": "Returns the closest point on a line to a circle.",
      "name": "closest_point_on_line_from_circle",
      "return_description": "The point that is closest to `c` on `l`",
      "signature": "point_2d closest_point_on_line_from_circle(const circle &c,const line &l);",
      "unique_global_name": "closest_point_on_line_from_circle"
    },
    {
      "description": "Returns the closest point on a rectangle to a circle.",
      "name": "closest_point_on_rect_from_circle",
      "return_description": "The point that is closest to `c` on `rect`",
      "signature": "point_2d closest_point_on_rect_from_circle(const circle &c,const rectangle &rect);",
      "unique_global_name": "closest_point_on_rect_from_circle"
    },
    {
      "description": "Calculates the closest point on a triangle to a circle. If the circle and\ntriangle do not intersect, the closest point on the triangle to the circle\nis returned. If the circle and triangle do intersect, the center of the\ncircle is returned.",
      "name": "closest_point_on_triangle_from_circle",
      "return_description": "The closest point on the triangle to the circle",
      "signature": "point_2d closest_point_on_triangle_from_circle(const circle &c,const triangle &tri);",
      "unique_global_name": "closest_point_on_triangle_from_circle"
    },
    {
      "description": "The furthest point on the circle to the given point.",
      "name": "distant_point_on_circle",
      "return_description": "The point on c that is furthest from `pt`",
      "signature": "point_2d distant_point_on_circle(const point_2d &pt,const circle &c);",
      "unique_global_name": "distant_point_on_circle"
    },
    {
      "description": "Determines the opposite side of a circle given a collision point and a\nheading.",
      "name": "distant_point_on_circle_heading",
      "return_description": "True when the `opposite_pt` is calculated, false when\nthe point would not collide with the circle when\nheading as indicated.",
      "signature": "bool distant_point_on_circle_heading(const point_2d &pt,const circle &c,const vector_2d &heading,point_2d &opposite_pt);",
      "unique_global_name": "distant_point_on_circle_heading"
    },
    {
      "description": "Calculates the distance from a ray cast from a point to a given circle.",
      "name": "ray_circle_intersect_distance",
      "return_description": "-1 if the ray does not hit the circle, otherwise the\ndistance from the origin to the circle bounds.",
      "signature": "float ray_circle_intersect_distance(const point_2d &ray_origin,const vector_2d &ray_heading,const circle &c);",
      "unique_global_name": "ray_circle_intersect_distance"
    },
    {
      "description": "Returns the two tangent points on the circle given the indicated point.",
      "name": "tangent_points",
      "return_description": "True if `from_pt` is outside of the circle, and tangent\npoints are calculated",
      "signature": "bool tangent_points(const point_2d &from_pt,const circle &c,point_2d &p1,point_2d &p2);",
      "unique_global_name": "tangent_points"
    },
    {
      "description": "Calculates the two points on a circles radius that lie along the given\nvector. This represents the points on the circle when the vector is\nplaced at the circle's center point.",
      "name": "widest_points",
      "return_description": null,
      "signature": "void widest_points(const circle &c,const vector_2d &along,point_2d &pt1,point_2d &pt2);",
      "unique_global_name": "widest_points"
    },
    {
      "description": "Returns the cosine of the supplied angle (in degrees).",
      "name": "cosine",
      "return_description": "the cosine of the supplied angle (in degrees).",
      "signature": "float cosine(float degrees);",
      "unique_global_name": "cosine"
    },
    {
      "description": "Returns the sine of the supplied angle (in degrees).",
      "name": "sine",
      "return_description": "the sine of the supplied angle (in degrees).",
      "signature": "float sine(float degrees);",
      "unique_global_name": "sine"
    },
    {
      "description": "Returns the tangent of the supplied angle (in degrees).",
      "name": "tangent",
      "return_description": "the tangent of the supplied angle (in degrees).",
      "signature": "float tangent(float degrees);",
      "unique_global_name": "tangent"
    },
    {
      "description": "Gets the closest point on the line to a given point.",
      "name": "closest_point_on_line",
      "return_description": "The point on the line that is closest to `from_pt`",
      "signature": "point_2d closest_point_on_line(const point_2d from_pt,const line &l);",
      "unique_global_name": "closest_point_on_line"
    },
    {
      "description": "Get the point closest to `from pt` that is on one of the supplied lines.",
      "name": "closest_point_on_lines",
      "return_description": "The point on one of the lines that is the closest point\non these lines to the `from pt`.",
      "signature": "point_2d closest_point_on_lines(const point_2d from_pt,const vector<line> &lines,int &line_idx);",
      "unique_global_name": "closest_point_on_lines"
    },
    {
      "description": "Create a line from one point to another.",
      "name": "line_from",
      "return_description": "A line from the start to the end point",
      "signature": "line line_from(const point_2d &start,const point_2d &end_pt);",
      "unique_global_name": "line_from_point_to_point"
    },
    {
      "description": "Creates a line that starts at a point, and follows a given vector.",
      "name": "line_from",
      "return_description": "A line from the start to end point",
      "signature": "line line_from(const point_2d &start,const vector_2d &offset);",
      "unique_global_name": "line_from_start_with_offset"
    },
    {
      "description": "Gets a line that goes from the origin and ends at the end of the vector.",
      "name": "line_from",
      "return_description": "A line from the origin to the end point",
      "signature": "line line_from(const vector_2d &v);",
      "unique_global_name": "line_from_vector"
    },
    {
      "description": "Create a line from one point to another.",
      "name": "line_from",
      "return_description": "A line from the start to the end point",
      "signature": "line line_from(double x1,double y1,double x2,double y2);",
      "unique_global_name": "line_from"
    },
    {
      "description": "Returns the point at which two lines would intersect. This point may lie\npast the end of one or both lines.",
      "name": "line_intersection_point",
      "return_description": "[description]",
      "signature": "bool line_intersection_point(const line &line1,const line &line2,point_2d &pt);",
      "unique_global_name": "line_intersection_point"
    },
    {
      "description": "Returns true if the line intersects the circle.",
      "name": "line_intersects_circle",
      "return_description": "True if the line `l` intersects the circle `c`",
      "signature": "bool line_intersects_circle(const line &l,const circle &c);",
      "unique_global_name": "line_intersects_circle"
    },
    {
      "description": "Returns true if the line intersects any of the lines.",
      "name": "line_intersects_lines",
      "return_description": "True if `line` intersects any of the lines in `lines`",
      "signature": "bool line_intersects_lines(const line &l,const vector<line> &lines);",
      "unique_global_name": "line_intersects_lines"
    },
    {
      "description": "Returns true if the line intersects the rectangle.",
      "name": "line_intersects_rect",
      "return_description": "True if `l` intersects `rect`",
      "signature": "bool line_intersects_rect(const line &l,const rectangle &rect);",
      "unique_global_name": "line_intersects_rect"
    },
    {
      "description": "Returns the length of a line.",
      "name": "line_length",
      "return_description": "The length of the line",
      "signature": "float line_length(const line &l);",
      "unique_global_name": "line_length"
    },
    {
      "description": "Returns the squared length of the line. You can also get the\n`line_length`.",
      "name": "line_length_squared",
      "return_description": "The squared length of the line",
      "signature": "float line_length_squared(const line &l);",
      "unique_global_name": "line_length_squared"
    },
    {
      "description": "Returns the center point of the line.",
      "name": "line_mid_point",
      "return_description": "The point that is at the center of the line",
      "signature": "point_2d line_mid_point(const line &l);",
      "unique_global_name": "line_mid_point"
    },
    {
      "description": "The line normal (a perpendicular vector).",
      "name": "line_normal",
      "return_description": "The line's normal vector",
      "signature": "vector_2d line_normal(const line &l);",
      "unique_global_name": "line_normal"
    },
    {
      "description": "Returns a text description of the line.",
      "name": "line_to_string",
      "return_description": "A text description of the line",
      "signature": "string line_to_string(const line &ln);",
      "unique_global_name": "line_to_string"
    },
    {
      "description": "Returns an array of lines from a supplied rectangle.",
      "name": "lines_from",
      "return_description": "An array containing 4 lines",
      "signature": "vector<line> lines_from(const rectangle &rect);",
      "unique_global_name": "lines_from_rectangle"
    },
    {
      "description": "Returns an array of lines from the details in the triangle.",
      "name": "lines_from",
      "return_description": "The lines from the triangle",
      "signature": "vector<line> lines_from(const triangle &t);",
      "unique_global_name": "lines_from_triangle"
    },
    {
      "description": "Returns true if the two lines intersect.",
      "name": "lines_intersect",
      "return_description": "True if the two lines intersect (share a common point).",
      "signature": "bool lines_intersect(const line &l1,const line &l2);",
      "unique_global_name": "lines_intersect"
    },
    {
      "description": "Returns a point at the given location.",
      "name": "point_at",
      "return_description": "A point at the given location",
      "signature": "point_2d point_at(double x,double y);",
      "unique_global_name": "point_at"
    },
    {
      "description": "Returns a point representing the origin.",
      "name": "point_at_origin",
      "return_description": "A point with x and y set to 0",
      "signature": "point_2d point_at_origin();",
      "unique_global_name": "point_at_origin"
    },
    {
      "description": "Returns true if the point `pt` is in the circle `c`.",
      "name": "point_in_circle",
      "return_description": "True if the point is within the area of the circle",
      "signature": "bool point_in_circle(const point_2d &pt,const circle &c);",
      "unique_global_name": "point_in_circle"
    },
    {
      "description": "Return true if the point is in the circle.",
      "name": "point_in_circle",
      "return_description": "True when the point is in the circle, otherwise it returns false.",
      "signature": "bool point_in_circle(double ptx,double pty,double cx,double cy,double radius);",
      "unique_global_name": "point_in_circle_with_values"
    },
    {
      "description": "Tests if a point is in a quad.",
      "name": "point_in_quad",
      "return_description": "True if pt lies within the area of q.",
      "signature": "bool point_in_quad(const point_2d &pt,const quad &q);",
      "unique_global_name": "point_in_quad"
    },
    {
      "description": "Returns true if point `pt` is in the Rectangle `rect`.",
      "name": "point_in_rectangle",
      "return_description": "True if the point is within the rectangle",
      "signature": "bool point_in_rectangle(const point_2d &pt,const rectangle &rect);",
      "unique_global_name": "point_in_rectangle"
    },
    {
      "description": "Returns true if the point is within the bounds of a Rectangle.",
      "name": "point_in_rectangle",
      "return_description": "true when the point is in the rectangle, otherwise it returns false.",
      "signature": "bool point_in_rectangle(double ptx,double pty,double rect_x,double rect_y,double rect_width,double rect_height);",
      "unique_global_name": "point_in_rectangle_with_values"
    },
    {
      "description": "Returns true if the point `pt` is in the Triangle `tri`.",
      "name": "point_in_triangle",
      "return_description": "True if the point is within the triangle",
      "signature": "bool point_in_triangle(const point_2d &pt,const triangle &tri);",
      "unique_global_name": "point_in_triangle"
    },
    {
      "description": "Returns the distance from a point to a line.",
      "name": "point_line_distance",
      "return_description": "The distance from `pt` to `l`",
      "signature": "float point_line_distance(const point_2d &pt,const line &l);",
      "unique_global_name": "point_line_distance"
    },
    {
      "description": "Calculate the `point_2d` that is offset from the `start_point` by the\n`offset`",
      "name": "point_offset_by",
      "return_description": "A new point as a result of moving by the offset from\nthe starting point",
      "signature": "point_2d point_offset_by(const point_2d &start_point,const vector_2d &offset);",
      "unique_global_name": "point_offset_by"
    },
    {
      "description": "Returns the point offset from the origin by the provided vector.",
      "name": "point_offset_from_origin",
      "return_description": "A new point as a result of moving by the offset from\nthe starting point",
      "signature": "point_2d point_offset_from_origin(const vector_2d &offset);",
      "unique_global_name": "point_offset_from_origin"
    },
    {
      "description": "Returns true if point `pt` is on the line `l`.",
      "name": "point_on_line",
      "return_description": "True if the point is on the line",
      "signature": "bool point_on_line(const point_2d &pt,const line &l);",
      "unique_global_name": "point_on_line"
    },
    {
      "description": "Returns true when the point `pt` is on the line `l`. The\nproximity value is used to set the sensitivity -- higher values\neffectively make the line thicker.",
      "name": "point_on_line",
      "return_description": "True if the point is on the line",
      "signature": "bool point_on_line(const point_2d &pt,const line &l,float proximity);",
      "unique_global_name": "point_on_line_with_proximity"
    },
    {
      "description": "Returns the angle between two points in degrees.",
      "name": "point_point_angle",
      "return_description": "The angle (in degrees) of the line between the points",
      "signature": "float point_point_angle(const point_2d &pt1,const point_2d &pt2);",
      "unique_global_name": "point_point_angle"
    },
    {
      "description": "Returns the distance between two points.",
      "name": "point_point_distance",
      "return_description": "The distance between the two points",
      "signature": "float point_point_distance(const point_2d &pt1,const point_2d &pt2);",
      "unique_global_name": "point_point_distance"
    },
    {
      "description": "Get a text description of the `point_2d`.",
      "name": "point_to_string",
      "return_description": "A string representation of the point",
      "signature": "string point_to_string(const point_2d &pt);",
      "unique_global_name": "point_to_string"
    },
    {
      "description": "Returns a random point within the bounds of the bitmap.",
      "name": "random_bitmap_point",
      "return_description": "A point within the bounds of the bitmap",
      "signature": "point_2d random_bitmap_point(bitmap bmp);",
      "unique_global_name": "random_bitmap_point"
    },
    {
      "description": "Returns a random point on the current window.",
      "name": "random_screen_point",
      "return_description": "A point within the bounds of the current window",
      "signature": "point_2d random_screen_point();",
      "unique_global_name": "random_screen_point"
    },
    {
      "description": "Returns a random point on the provided window.",
      "name": "random_window_point",
      "return_description": "A point within the bounds of the window",
      "signature": "point_2d random_window_point(window wind);",
      "unique_global_name": "random_window_point"
    },
    {
      "description": "Returns True of `pt1` is at the same point as `pt2`. This checks at an\ninteger level, indicating the two points refer to the same pixel.",
      "name": "same_point",
      "return_description": "True if the two points are at the same location",
      "signature": "bool same_point(const point_2d &pt1,const point_2d &pt2);",
      "unique_global_name": "same_point"
    },
    {
      "description": "Returns a quad from the passed in points.",
      "name": "quad_from",
      "return_description": "A quad from the passed in points",
      "signature": "quad quad_from(const point_2d &p1,const point_2d &p2,const point_2d &p3,const point_2d &p4);",
      "unique_global_name": "quad_from_points"
    },
    {
      "description": "Returns a quad from the x-y points of a given recatangle",
      "name": "quad_from",
      "return_description": "A quad at the same location as the rectangle",
      "signature": "quad quad_from(const rectangle &rect);",
      "unique_global_name": "quad_from_rectangle"
    },
    {
      "description": "Returns a quad from the rectangle, then applies the transformation to\nthe quads points.",
      "name": "quad_from",
      "return_description": "A quad that represents the rectangle after the transformation.",
      "signature": "quad quad_from(const rectangle &rect,const matrix_2d &transform);",
      "unique_global_name": "quad_from_rectangle_with_transformation"
    },
    {
      "description": "Returns a quad for the passed in x & y points.",
      "name": "quad_from",
      "return_description": "A quad with the indicated points",
      "signature": "quad quad_from(double x_top_left,double y_top_left,double x_top_right,double y_top_right,double x_bottom_left,double y_bottom_left,double x_bottom_right,double y_bottom_right );",
      "unique_global_name": "quad_from"
    },
    {
      "description": "Returns true if two quads intersect.",
      "name": "quads_intersect",
      "return_description": "True if the two quads intersect.",
      "signature": "bool quads_intersect(const quad &q1,const quad &q2);",
      "unique_global_name": "quads_intersect"
    },
    {
      "description": "Change a point in a quad.",
      "name": "set_quad_point",
      "return_description": null,
      "signature": "void set_quad_point(quad &q,int idx,const point_2d &value);",
      "unique_global_name": "set_quad_point"
    },
    {
      "description": "Returns the two triangles that make up a quad in a vector.",
      "name": "triangles_from",
      "return_description": "A vector with the two triangles from the quad.",
      "signature": "vector<triangle> triangles_from(const quad &q);",
      "unique_global_name": "triangles_from"
    },
    {
      "description": "Return a rectangle that is inset an amount from a given rectangle.",
      "name": "inset_rectangle",
      "return_description": "A new rectangle created inset from `rect`",
      "signature": "rectangle inset_rectangle(const rectangle &rect,float inset_amount);",
      "unique_global_name": "inset_rectangle"
    },
    {
      "description": "Returns a rectangle that represents the intersection of two rectangles.",
      "name": "intersection",
      "return_description": "The intersection of rect1 and rect2.",
      "signature": "rectangle intersection(const rectangle &rect1,const rectangle &rect2);",
      "unique_global_name": "intersection"
    },
    {
      "description": "Returns a rectangle that surrounds a given circle",
      "name": "rectangle_around",
      "return_description": "A rectangle that will surround the circle",
      "signature": "rectangle rectangle_around(const circle &c);",
      "unique_global_name": "rectangle_around_circle"
    },
    {
      "description": "Returns a rectangle that surrounds a given line segment",
      "name": "rectangle_around",
      "return_description": "A rectangle that will surround the line",
      "signature": "rectangle rectangle_around(const line &l);",
      "unique_global_name": "rectangle_around_line"
    },
    {
      "description": "Returns a rectangle that surrounds a given quad.",
      "name": "rectangle_around",
      "return_description": "A rectangle that will surround the quad",
      "signature": "rectangle rectangle_around(const quad &q);",
      "unique_global_name": "rectangle_around_quad"
    },
    {
      "description": "Returns a rectangle that surrounds a given triangle",
      "name": "rectangle_around",
      "return_description": "A rectangle that will surround the triangle",
      "signature": "rectangle rectangle_around(const triangle &t);",
      "unique_global_name": "rectangle_around_triangle"
    },
    {
      "description": "The location of the bottom of the rectangle.",
      "name": "rectangle_bottom",
      "return_description": "The distance from the top of the screen to the bottom of\nthe rectangle.",
      "signature": "float rectangle_bottom(const rectangle &rect);",
      "unique_global_name": "rectangle_bottom"
    },
    {
      "description": "Returns the center point of a given rectangle",
      "name": "rectangle_center",
      "return_description": "The center point of the vector",
      "signature": "point_2d rectangle_center(const rectangle &rect);",
      "unique_global_name": "rectangle_center"
    },
    {
      "description": "Returns a rectangle at the specified point with a given width and height",
      "name": "rectangle_from",
      "return_description": "A rectangle with the specified dimensions and location",
      "signature": "rectangle rectangle_from(const point_2d pt,const double width,const double height);",
      "unique_global_name": "rectangle_from_point_and_size"
    },
    {
      "description": "Returns a rectangle with pt1 and pt2 defining the two distant edge points.",
      "name": "rectangle_from",
      "return_description": "A rectangle enclosing the two points.",
      "signature": "rectangle rectangle_from(const point_2d pt1,const point_2d pt2);",
      "unique_global_name": "rectangle_from_points"
    },
    {
      "description": "Returns a rectangle from a given x,y location with the specified width\nand height.",
      "name": "rectangle_from",
      "return_description": "A rectangle with the specified dimensions and location.",
      "signature": "rectangle rectangle_from(double x,double y,double width,double height);",
      "unique_global_name": "rectangle_from"
    },
    {
      "description": "The location of the left edge of the rectangle.",
      "name": "rectangle_left",
      "return_description": "The distance from the left of the screen to the left side of\nthe rectangle.",
      "signature": "float rectangle_left(const rectangle &rect);",
      "unique_global_name": "rectangle_left"
    },
    {
      "description": "Returns a rectangle that is moved by the provided vector.",
      "name": "rectangle_offset_by",
      "return_description": "A new rectangle that represents the original rectangle\nafter being moved by the offset vector.",
      "signature": "rectangle rectangle_offset_by(const rectangle &rect,const vector_2d &offset);",
      "unique_global_name": "rectangle_offset_by"
    },
    {
      "description": "The location of the right edge of the rectangle.",
      "name": "rectangle_right",
      "return_description": "The distance from the left of the screen to the right side\nof the rectangle.",
      "signature": "float rectangle_right(const rectangle &rect);",
      "unique_global_name": "rectangle_right"
    },
    {
      "description": "Get a text representation of the passed in rectangle.",
      "name": "rectangle_to_string",
      "return_description": "A string representation of the rectangle.",
      "signature": "string rectangle_to_string(const rectangle &rect);",
      "unique_global_name": "rectangle_to_string"
    },
    {
      "description": "The top of the rectangle.",
      "name": "rectangle_top",
      "return_description": "Its distance from the top of the screen.",
      "signature": "float rectangle_top(const rectangle &rect);",
      "unique_global_name": "rectangle_top"
    },
    {
      "description": "Returns true if the two rectangles intersect.",
      "name": "rectangles_intersect",
      "return_description": "True when rect1 and rect2 intersect.",
      "signature": "bool rectangles_intersect(const rectangle &rect1,const rectangle &rect2);",
      "unique_global_name": "rectangles_intersect"
    },
    {
      "description": "Return the barycenter of the triangle. This is one way of calculating the\ncenter point of a triangle.",
      "name": "triangle_barycenter",
      "return_description": "The point that is the barycenter of `tri`",
      "signature": "point_2d triangle_barycenter(const triangle &tri);",
      "unique_global_name": "triangle_barycenter"
    },
    {
      "description": "Generate a triangle from a set of points.",
      "name": "triangle_from",
      "return_description": "A triangle with the indicated points",
      "signature": "triangle triangle_from(const point_2d &p1,const point_2d &p2,const point_2d &p3);",
      "unique_global_name": "triangle_from"
    },
    {
      "description": "Generate a triangle from a set of points.",
      "name": "triangle_from",
      "return_description": "A triangle at the indicated points",
      "signature": "triangle triangle_from(double x1,double y1,double x2,double y2,double x3,double y3);",
      "unique_global_name": "triangle_from__from_coordinates"
    },
    {
      "description": "Returns true if the triangle intersects with the rectangle.",
      "name": "triangle_rectangle_intersect",
      "return_description": "True if the triangle and rect intersect",
      "signature": "bool triangle_rectangle_intersect(const triangle &tri,const rectangle &rect);",
      "unique_global_name": "triangle_rectangle_intersect"
    },
    {
      "description": "Returns a text description of the triangle.",
      "name": "triangle_to_string",
      "return_description": "A text description of the triangle.",
      "signature": "string triangle_to_string(const triangle &tri);",
      "unique_global_name": "triangle_to_string"
    },
    {
      "description": "Returns true if the two triangles intersect.",
      "name": "triangles_intersect",
      "return_description": "True if the two triangles intersect",
      "signature": "bool triangles_intersect(const triangle &t1,const triangle &t2);",
      "unique_global_name": "triangles_intersect"
    },
    {
      "description": "Tests if a bitmap drawn at `pt` would intersect with a circle.",
      "name": "bitmap_circle_collision",
      "return_description": "True if a drawn pixel in the cell of the bitmap will\nintersect with `circ` when drawn.",
      "signature": "bool bitmap_circle_collision(bitmap bmp,const point_2d& pt,const circle& circ);",
      "unique_global_name": "bitmap_circle_collision_at_point"
    },
    {
      "description": "Tests if a bitmap drawn at `x`, `y` would intersect with a circle.",
      "name": "bitmap_circle_collision",
      "return_description": "True if a drawn pixel in the bitmap will\nintersect with `circ` when drawn.",
      "signature": "bool bitmap_circle_collision(bitmap bmp,double x,double y,const circle& circ);",
      "unique_global_name": "bitmap_circle_collision"
    },
    {
      "description": "Tests if a bitmap cell drawn using a passed in translation, will\nintersect with a circle. You can use this to detect collisions between\nbitmaps and circles.",
      "name": "bitmap_circle_collision",
      "return_description": "True if a drawn pixel in the cell of the bitmap will\nintersect with `circ` when drawn.",
      "signature": "bool bitmap_circle_collision(bitmap bmp,int cell,const matrix_2d& translation,const circle& circ);",
      "unique_global_name": "bitmap_circle_collision_for_cell_with_translation"
    },
    {
      "description": "Tests if a bitmap cell drawn at `pt` would intersect with a circle.",
      "name": "bitmap_circle_collision",
      "return_description": "True if a drawn pixel in the cell of the bitmap will\nintersect with `circ` when drawn.",
      "signature": "bool bitmap_circle_collision(bitmap bmp,int cell,const point_2d& pt,const circle& circ);",
      "unique_global_name": "bitmap_circle_collision_for_cell_at_point"
    },
    {
      "description": "Tests if a bitmap cell drawn at `x`, `y` would intersect with a circle.",
      "name": "bitmap_circle_collision",
      "return_description": "True if a drawn pixel in the bitmap will\nintersect with `circ` when drawn.",
      "signature": "bool bitmap_circle_collision(bitmap bmp,int cell,double x,double y,const circle& circ);",
      "unique_global_name": "bitmap_circle_collision_for_cell"
    },
    {
      "description": "Check if two bitmaps collide.",
      "name": "bitmap_collision",
      "return_description": "True if pixels in the two bitmaps would collide/overlap",
      "signature": "bool bitmap_collision(bitmap bmp1,double x1,double y1,bitmap bmp2,double x2,double y2);",
      "unique_global_name": "bitmap_collision"
    },
    {
      "description": "Check if two bitmaps collide.",
      "name": "bitmap_collision",
      "return_description": "True if pixels in the two bitmaps would collide/overlap",
      "signature": "bool bitmap_collision(bitmap bmp1,const point_2d &pt1,bitmap bmp2,const point_2d &pt2);",
      "unique_global_name": "bitmap_collision_at_points"
    },
    {
      "description": "Check if two bitmaps collide, based on their cell and transform\nmatricies.",
      "name": "bitmap_collision",
      "return_description": "True if pixels in the two bitmaps would collide/overlap",
      "signature": "bool bitmap_collision(bitmap bmp1,int cell1,const matrix_2d &matrix1,bitmap bmp2,int cell2,const matrix_2d &matrix2);",
      "unique_global_name": "bitmap_collision_for_cells_with_translations"
    },
    {
      "description": "Check if two bitmaps collide.",
      "name": "bitmap_collision",
      "return_description": "True if pixels in the two bitmaps would collide/overlap",
      "signature": "bool bitmap_collision(bitmap bmp1,int cell1,const point_2d &pt1,bitmap bmp2,int cell2,const point_2d &pt2);",
      "unique_global_name": "bitmap_collision_for_cells_at_points"
    },
    {
      "description": "Check if two bitmaps collide.",
      "name": "bitmap_collision",
      "return_description": "True if pixels in the two bitmaps would collide/overlap",
      "signature": "bool bitmap_collision(bitmap bmp1,int cell1,double x1,double y1,bitmap bmp2,int cell2,double x2,double y2);",
      "unique_global_name": "bitmap_collision_for_cells"
    },
    {
      "description": "Tests if a bitmap drawn using the passed in translation matrix would draw a pixel\nat the passed in point. Use to check collisions between a point and a bitmap.",
      "name": "bitmap_point_collision",
      "return_description": "True if drawing the bitmap, using the passed in translation,\nwill draw a pixel at the indicated point.",
      "signature": "bool bitmap_point_collision(bitmap bmp,const matrix_2d& translation,const point_2d& pt);",
      "unique_global_name": "bitmap_point_collision_with_translation"
    },
    {
      "description": "Tests if a bitmap drawn at the `bmp_pt` point would draw a pixel\nat point `pt`. Use to check collisions between a point and a bitmap.",
      "name": "bitmap_point_collision",
      "return_description": "True if drawing the bitmap, at `bmp_pt`,\nwill draw a pixel at the indicated point (`pt`).",
      "signature": "bool bitmap_point_collision(bitmap bmp,const point_2d &bmp_pt,const point_2d& pt);",
      "unique_global_name": "bitmap_point_collision_at_point"
    },
    {
      "description": "Tests if a bitmap drawn at x,y would draw a pixel at the passed in point. Use \nto check collisions between a point and a bitmap.",
      "name": "bitmap_point_collision",
      "return_description": "True if drawing the bitmap, at the indicated location,\nwill draw a pixel at the indicated point.",
      "signature": "bool bitmap_point_collision(bitmap bmp,double bmp_x,double bmp_y,double x,double y);",
      "unique_global_name": "bitmap_point_collision"
    },
    {
      "description": "Tests if a bitmap cell drawn using the passed in translation matrix would draw a pixel\nat the passed in point.",
      "name": "bitmap_point_collision",
      "return_description": "True if drawing the bitmap, using the passed in translation,\nwill draw a pixel at the indicated point.",
      "signature": "bool bitmap_point_collision(bitmap bmp,int cell,const matrix_2d& translation,const point_2d& pt);",
      "unique_global_name": "bitmap_point_collision_for_cell_with_translation"
    },
    {
      "description": "Tests if a cell of a bitmap drawn at x,y would draw a pixel at the passed in point. Use\nto check collisions between a point and a bitmap.",
      "name": "bitmap_point_collision",
      "return_description": "True if drawing the bitmap cell, at the indicated location,\nwill draw a pixel at the indicated point.",
      "signature": "bool bitmap_point_collision(bitmap bmp,int cell,const point_2d &bmp_pt,const point_2d& pt);",
      "unique_global_name": "bitmap_point_collision_for_cell_at_point"
    },
    {
      "description": "Tests if a cell of a bitmap drawn at x,y would draw a pixel at the passed in point. Use\nto check collisions between a point and a bitmap.",
      "name": "bitmap_point_collision",
      "return_description": "True if drawing the bitmap cell, at the indicated location,\nwill draw a pixel at the indicated point.",
      "signature": "bool bitmap_point_collision(bitmap bmp,int cell,double bmp_x,double bmp_y,double x,double y);",
      "unique_global_name": "bitmap_point_collision_for_cell"
    },
    {
      "description": "Tests if a bitmap drawn at `pt` would intersect with a rectangle.",
      "name": "bitmap_rectangle_collision",
      "return_description": "True if a drawn pixel in the cell of the bitmap will\nintersect with `rect` when drawn.",
      "signature": "bool bitmap_rectangle_collision(bitmap bmp,const point_2d& pt,const rectangle& rect);",
      "unique_global_name": "bitmap_rectangle_collision_at_point"
    },
    {
      "description": "Tests if a bitmap drawn at `x`, `y` would intersect with a rectangle.",
      "name": "bitmap_rectangle_collision",
      "return_description": "True if a drawn pixel in the bitmap will\nintersect with `rect` when drawn.",
      "signature": "bool bitmap_rectangle_collision(bitmap bmp,double x,double y,const rectangle& rect);",
      "unique_global_name": "bitmap_rectangle_collision"
    },
    {
      "description": "Tests if a bitmap cell drawn using a passed in translation, will\nintersect with a rectangle. You can use this to detect collisions between\nbitmaps and rectangles.",
      "name": "bitmap_rectangle_collision",
      "return_description": "True if a drawn pixel in the cell of the bitmap will\nintersect with `rect` when drawn.",
      "signature": "bool bitmap_rectangle_collision(bitmap bmp,int cell,const matrix_2d& translation,const rectangle& rect);",
      "unique_global_name": "bitmap_rectangle_collision_for_cell_with_translation"
    },
    {
      "description": "Tests if a bitmap cell drawn at `pt` would intersect with a rectangle.",
      "name": "bitmap_rectangle_collision",
      "return_description": "True if a drawn pixel in the cell of the bitmap will\nintersect with `rect` when drawn.",
      "signature": "bool bitmap_rectangle_collision(bitmap bmp,int cell,const point_2d& pt,const rectangle& rect);",
      "unique_global_name": "bitmap_rectangle_collision_for_cell_at_point"
    },
    {
      "description": "Tests if a cell of the bitmap drawn at `x`, `y` would intersect with a rectangle.",
      "name": "bitmap_rectangle_collision",
      "return_description": "True if a drawn pixel in the bitmap will\nintersect with `rect` when drawn.",
      "signature": "bool bitmap_rectangle_collision(bitmap bmp,int cell,double x,double y,const rectangle& rect);",
      "unique_global_name": "bitmap_rectangle_collision_for_cell"
    },
    {
      "description": "Tests if a sprite will collide with a bitmap drawn at the indicated\nlocation.",
      "name": "sprite_bitmap_collision",
      "return_description": "True if the sprite collides with the bitmap when drawn\nat the indicated location.",
      "signature": "bool sprite_bitmap_collision(sprite s,bitmap bmp,double x,double y);",
      "unique_global_name": "sprite_bitmap_collision"
    },
    {
      "description": "Tests if a sprite will collide with a bitmap drawn at the indicated\nlocation.",
      "name": "sprite_bitmap_collision",
      "return_description": "True if the sprite collides with the bitmap cell when drawn\nat the indicated location.",
      "signature": "bool sprite_bitmap_collision(sprite s,bitmap bmp,int cell,const point_2d &pt);",
      "unique_global_name": "sprite_bitmap_collision_with_cell_at_point"
    },
    {
      "description": "Tests if a sprite will collide with a bitmap drawn at the indicated\nlocation.",
      "name": "sprite_bitmap_collision",
      "return_description": "True if the sprite collides with the bitmap cell when drawn\nat the indicated location.",
      "signature": "bool sprite_bitmap_collision(sprite s,bitmap bmp,int cell,double x,double y);",
      "unique_global_name": "sprite_bitmap_collision_with_cell"
    },
    {
      "description": "Tests if two given sprites `s1` and `s2` are collided",
      "name": "sprite_collision",
      "return_description": "return `true` if both `s1` and `s2` are colliding, false otherwise.",
      "signature": "bool sprite_collision(sprite s1,sprite s2);",
      "unique_global_name": "sprite_collision"
    },
    {
      "description": "Tests if a sprite is drawn at a given point.",
      "name": "sprite_point_collision",
      "return_description": "True if the sprite it drawn at the indicated point",
      "signature": "bool sprite_point_collision(sprite s,const point_2d& pt);",
      "unique_global_name": "sprite_point_collision"
    },
    {
      "description": "Tests if a sprite is drawn within an given area (rectangle).",
      "name": "sprite_rectangle_collision",
      "return_description": "True if the sprite it drawn in the rectangle area",
      "signature": "bool sprite_rectangle_collision(sprite s,const rectangle& rect);",
      "unique_global_name": "sprite_rectangle_collision"
    },
    {
      "description": "Use a matrix to transform all of the points in a quad.",
      "name": "apply_matrix",
      "return_description": null,
      "signature": "void apply_matrix(const matrix_2d &matrix,quad &q);",
      "unique_global_name": "apply_matrix_to_quad"
    },
    {
      "description": "Use a matrix to transform all of the points in a triangle.",
      "name": "apply_matrix",
      "return_description": null,
      "signature": "void apply_matrix(const matrix_2d &m,triangle &tri);",
      "unique_global_name": "apply_matrix_to_triangle"
    },
    {
      "description": "Returns the identity matrix. When a matrix_2d or Vector is multiplied by\nthe identity matrix the result is the original matrix or vector.",
      "name": "identity_matrix",
      "return_description": "An identify matrix.",
      "signature": "matrix_2d identity_matrix();",
      "unique_global_name": "identity_matrix"
    },
    {
      "description": "Calculate the inverse of a matrix.",
      "name": "matrix_inverse",
      "return_description": "A matrix that is the inverse of m",
      "signature": "matrix_2d matrix_inverse(const matrix_2d &m);",
      "unique_global_name": "matrix_inverse"
    },
    {
      "description": "Multiplies the `point_2d` parameter `v with the `matrix_2d` `m and\nreturns the result as a `point_2d`. Use this to transform the vector with\nthe matrix (to apply scaling, rotation or translation effects).",
      "name": "matrix_multiply",
      "return_description": "A new point, the result of applying the transformation to pt.",
      "signature": "point_2d matrix_multiply(const matrix_2d &m,const point_2d &pt);",
      "unique_global_name": "matrix_multiply_point"
    },
    {
      "description": "Multiplies the two `matrix_2d` parameters, `m1` by `m2`, and returns\nthe result as a new `matrix_2d`. Use this to combine the effects to two\nmatrix transformations.",
      "name": "matrix_multiply",
      "return_description": "The result of multiplying m1 by m2",
      "signature": "matrix_2d matrix_multiply(const matrix_2d &m1,const matrix_2d &m2);",
      "unique_global_name": "matrix_multiply_matrix"
    },
    {
      "description": "Multiplies the `Vector` parameter `v` with the `matrix_2d` `m` and\nreturns the result as a `Vector`. Use this to transform the vector with\nthe matrix (to apply scaling, rotation or translation effects).",
      "name": "matrix_multiply",
      "return_description": "A new vector, the result of applying the transformation to v.",
      "signature": "vector_2d matrix_multiply(const matrix_2d &m,const vector_2d &v);",
      "unique_global_name": "matrix_multiply_vector"
    },
    {
      "description": "This function returns a string representation of a Matrix.",
      "name": "matrix_to_string",
      "return_description": "A string representation of the matrix.",
      "signature": "string matrix_to_string(const matrix_2d &matrix);",
      "unique_global_name": "matrix_to_string"
    },
    {
      "description": "Returns a rotation matrix that rotates 2d points by the angle.",
      "name": "rotation_matrix",
      "return_description": "A matrix that encodes the rotation by a number of degrees.",
      "signature": "matrix_2d rotation_matrix(double deg);",
      "unique_global_name": "rotation_matrix"
    },
    {
      "description": "Create a scale matrix that scales x and y to\ndifferent degrees.",
      "name": "scale_matrix",
      "return_description": "A matrix that will scale points based on scale parameter.",
      "signature": "matrix_2d scale_matrix(const point_2d &scale);",
      "unique_global_name": "scale_matrix_from_point"
    },
    {
      "description": "Create a scale matrix that scales x and y to\ndifferent degrees.",
      "name": "scale_matrix",
      "return_description": "A matrix that will scale points based on scale parameter.",
      "signature": "matrix_2d scale_matrix(const vector_2d &scale);",
      "unique_global_name": "scale_matrix_from_vector"
    },
    {
      "description": "Returns a matrix that can be used to scale 2d points (both x and y).",
      "name": "scale_matrix",
      "return_description": "A matrix to scale points by.",
      "signature": "matrix_2d scale_matrix(double scale);",
      "unique_global_name": "scale_matrix"
    },
    {
      "description": "Create a matrix that can scale, rotate then translate geometry points.",
      "name": "scale_rotate_translate_matrix",
      "return_description": "A matrix that will scale, rotate, and translate.",
      "signature": "matrix_2d scale_rotate_translate_matrix(const point_2d &scale,double deg,const point_2d &translate);",
      "unique_global_name": "scale_rotate_translate_matrix"
    },
    {
      "description": "Returns a translation matric used to translate 2d points by the\ndistance in the point_2d.",
      "name": "translation_matrix",
      "return_description": "A matrix that will move points by amount in pt",
      "signature": "matrix_2d translation_matrix(const point_2d &pt);",
      "unique_global_name": "translation_matrix_to_point"
    },
    {
      "description": "Returns a translation matric used to translate 2d points by the\ndistance in the vector_2d.",
      "name": "translation_matrix",
      "return_description": "A matrix that will move points by amount in pt",
      "signature": "matrix_2d translation_matrix(const vector_2d &pt);",
      "unique_global_name": "translation_matrix_from_vector"
    },
    {
      "description": "Returns a matrix that can be used to translate 2d points. Moving them\nby dx and dy.",
      "name": "translation_matrix",
      "return_description": "A matrix that will move points by dx, dy",
      "signature": "matrix_2d translation_matrix(double dx,double dy);",
      "unique_global_name": "translation_matrix"
    },
    {
      "description": "Calculates the angle from one vector to another.",
      "name": "angle_between",
      "return_description": "The angle of the line from the end of `v1` to the end of `v2`",
      "signature": "double angle_between(const vector_2d &v1,const vector_2d &v2);",
      "unique_global_name": "angle_between"
    },
    {
      "description": "Calculates the dot product (scalar product) between the two vector\nparameters provided (`v1` and `v2`). It returns the result as a\nscalar value.\n\nIf the result is 0.0 it means that the vectors are orthogonal (at right\nangles to each other). If `v1` and `v2` are unit vectors (length of\n1.0) and the dot product is 1.0, it means that `v1` and `v2` vectors\nare parallel.",
      "name": "dot_product",
      "return_description": "The dot product of `v1` . `v2`",
      "signature": "double dot_product(const vector_2d &v1,const vector_2d &v2);",
      "unique_global_name": "dot_product"
    },
    {
      "description": "Returns if the vector is a null/zero vector -- having no size or direction.",
      "name": "is_zero_vector",
      "return_description": "True if `v` has no magnitude.",
      "signature": "bool is_zero_vector(const vector_2d &v);",
      "unique_global_name": "is_zero_vector"
    },
    {
      "description": "Casts a ray in a heading and returns true is it intersects with a line",
      "name": "ray_intersection_point",
      "return_description": "True if the line and ray will intersect, in which case\nthe value of `pt` will be changed to be the point where\nthe intersection occurs.",
      "signature": "bool ray_intersection_point(const point_2d &from_pt,const vector_2d &heading,const line &l,point_2d &pt);",
      "unique_global_name": "ray_intersection_point"
    },
    {
      "description": "Returns the unit vector of the parameter vector (v). The unit vector has a\nmagnitude of 1, resulting in a vector that indicates the direction of\nthe original vector.",
      "name": "unit_vector",
      "return_description": "The unit vector of `v`",
      "signature": "vector_2d unit_vector(const vector_2d &v);",
      "unique_global_name": "unit_vector"
    },
    {
      "description": "Adds the two passed in vectors returns the result as new `vector_2d`.",
      "name": "vector_add",
      "return_description": "The result of adding the movements of the two vectors\ntogether.",
      "signature": "vector_2d vector_add(const vector_2d &v1,const vector_2d &v2);",
      "unique_global_name": "vector_add"
    },
    {
      "description": "Calculates the angle of a vector",
      "name": "vector_angle",
      "return_description": "The angle of the vector in degrees",
      "signature": "double vector_angle(const vector_2d v);",
      "unique_global_name": "vector_angle"
    },
    {
      "description": "Returns a `vector_2d` from the supplied angle and distance.",
      "name": "vector_from_angle",
      "return_description": "A vector that will move things at that angle and\nmagnitude",
      "signature": "vector_2d vector_from_angle(double angle,double magnitude);",
      "unique_global_name": "vector_from_angle"
    },
    {
      "description": "Returns a vector that points from the start to the end of a line.",
      "name": "vector_from_line",
      "return_description": "A vector that will move things from the start to the end of the\nline",
      "signature": "vector_2d vector_from_line(const line &l);",
      "unique_global_name": "vector_from_line"
    },
    {
      "description": "Returns a vector from a point to a rectangle.",
      "name": "vector_from_point_to_rect",
      "return_description": "A vector representing the distance and direction from `pt`\nto `rect`",
      "signature": "vector_2d vector_from_point_to_rect(const point_2d &pt,const rectangle &rect);",
      "unique_global_name": "vector_from_point_to_rect"
    },
    {
      "description": "Returns true if the resulting vector would end in the rectangle if\nplaced at the origin.",
      "name": "vector_in_rect",
      "return_description": "True if the vector would end in the rectangle",
      "signature": "bool vector_in_rect(const vector_2d &v,const rectangle &rect);",
      "unique_global_name": "vector_in_rect"
    },
    {
      "description": "Returns a new Vector that is an inverted version of the parameter\nvector (v). In other words, the -/+ sign of the x and y values are changed.",
      "name": "vector_invert",
      "return_description": "The inverse (reverse) of `v`",
      "signature": "vector_2d vector_invert(const vector_2d &v);",
      "unique_global_name": "vector_invert"
    },
    {
      "description": "Returns a scaled vector that ensures the new vector points\nin the same direction as v, but has a magnitude that is\nlimited to the length specified in the limit prameter.",
      "name": "vector_limit",
      "return_description": "A new vector in the same direction as v, but with a\nmagnitude that is less than or equal to the limit.",
      "signature": "vector_2d vector_limit(const vector_2d &v,double limit);",
      "unique_global_name": "vector_limit"
    },
    {
      "description": "Returns the magnitude (or \"length\") of the vector.",
      "name": "vector_magnitude",
      "return_description": "Its magnitude",
      "signature": "double vector_magnitude(const vector_2d &v);",
      "unique_global_name": "vector_magnitude"
    },
    {
      "description": "Returns the squared magnitude (or \"length\") of the vector.",
      "name": "vector_magnitude_squared",
      "return_description": "Its squared magnitude",
      "signature": "double vector_magnitude_squared(const vector_2d &v);",
      "unique_global_name": "vector_magnitude_squared"
    },
    {
      "description": "Multiplies the vector by the passed in value.",
      "name": "vector_multiply",
      "return_description": "A new vector",
      "signature": "vector_2d vector_multiply(const vector_2d &v1,double s);",
      "unique_global_name": "vector_multiply"
    },
    {
      "description": "Returns a new `vector_2d` that is perpendicular (\"normal\") to the parameter\nvector `v` provided. The concept of a \"normal\" vector is usually\nextracted from (or associated with) a line.\n\nNote: when passed a zero or null vector (a vector with no\nmagnitude or direction) then this function returns a zero/null vector.",
      "name": "vector_normal",
      "return_description": "The normal of `v`",
      "signature": "vector_2d vector_normal(const vector_2d &v);",
      "unique_global_name": "vector_normal"
    },
    {
      "description": "Returns a vector to back one circle out of another, assuming the first circle was\nmoving at a specified velocity.",
      "name": "vector_out_of_circle_from_circle",
      "return_description": "A vector that can move the circle out of the bounds",
      "signature": "vector_2d vector_out_of_circle_from_circle(const circle &src,const circle &bounds,const vector_2d &velocity);",
      "unique_global_name": "vector_out_of_circle_from_circle"
    },
    {
      "description": "Returns the vector out to move a point back out of a circle,\ngiven the point was moving at the specified velocity.",
      "name": "vector_out_of_circle_from_point",
      "return_description": "A vector that can move the point out of the circle",
      "signature": "vector_2d vector_out_of_circle_from_point(const point_2d &pt,const circle &c,const vector_2d &velocity);",
      "unique_global_name": "vector_out_of_circle_from_point"
    },
    {
      "description": "Returns a vector that can be used to move a circle back out of a rectangle,\ngiven that the circle is moving at the specified velocity.",
      "name": "vector_out_of_rect_from_circle",
      "return_description": "A vector that will move the circle out of the rectangle",
      "signature": "vector_2d vector_out_of_rect_from_circle(const circle &c,const rectangle &rect,const vector_2d &velocity);",
      "unique_global_name": "vector_out_of_rect_from_circle"
    },
    {
      "description": "Determines the vector needed to move back from point `pt` out of rectangle `rect` given\nthe point was moving at the velocity specified.",
      "name": "vector_out_of_rect_from_point",
      "return_description": "A vector that can move the point outside of the\nrectangle.",
      "signature": "vector_2d vector_out_of_rect_from_point(const point_2d &pt,const rectangle &rect,const vector_2d &velocity);",
      "unique_global_name": "vector_out_of_rect_from_point"
    },
    {
      "description": "Returns the vector needed to move rectangle `src` back out of rectangle `bounds`\nassuming the rectangle was moving at the velocity specified.",
      "name": "vector_out_of_rect_from_rect",
      "return_description": "A vector that can move the rectangle out of the bounds",
      "signature": "vector_2d vector_out_of_rect_from_rect(const rectangle &src,const rectangle &bounds,const vector_2d &velocity);",
      "unique_global_name": "vector_out_of_rect_from_rect"
    },
    {
      "description": "Returns a `vector_2d` created from the difference from the `p1` to\nthe second `p2` points (`Point2D`).",
      "name": "vector_point_to_point",
      "return_description": "A vector that will move things from the starting point to\nthe ending point",
      "signature": "vector_2d vector_point_to_point(const point_2d &start,const point_2d &end_pt);",
      "unique_global_name": "vector_point_to_point"
    },
    {
      "description": "Subtracts the second vector parameter (`v2`) from the first vector\n(`v1`) and returns the result as new `vector_2d`.",
      "name": "vector_subtract",
      "return_description": "The result of subtracting the movements of `v2` from `v1`.",
      "signature": "vector_2d vector_subtract(const vector_2d &v1,const vector_2d &v2);",
      "unique_global_name": "vector_subtract"
    },
    {
      "description": "Returns a new `vector_2d` using the x and y value of a `point_2d` parameter.\nThis is a vector from the origin to that point.",
      "name": "vector_to",
      "return_description": "A vector from the origin to `p1`",
      "signature": "vector_2d vector_to(const point_2d &p1);",
      "unique_global_name": "vector_to_point"
    },
    {
      "description": "Returns a vector to the indicated point.",
      "name": "vector_to",
      "return_description": "A vector that will move things the indicated amount",
      "signature": "vector_2d vector_to(double x,double y);",
      "unique_global_name": "vector_to"
    },
    {
      "description": "Get a text description of the `vector_2d`.",
      "name": "vector_to_string",
      "return_description": "A string representation of the vector",
      "signature": "string vector_to_string(const vector_2d &v);",
      "unique_global_name": "vector_to_string"
    },
    {
      "description": "Determines if two vectors are the same.",
      "name": "vectors_equal",
      "return_description": "True if the two vectors are equal.",
      "signature": "bool vectors_equal(const vector_2d &v1,const vector_2d v2);",
      "unique_global_name": "vectors_equal"
    },
    {
      "description": "Determines if two vectors are not the same.",
      "name": "vectors_not_equal",
      "return_description": "True if the two vectors are different.",
      "signature": "bool vectors_not_equal(const vector_2d &v1,const vector_2d v2);",
      "unique_global_name": "vectors_not_equal"
    }
  ]
}
