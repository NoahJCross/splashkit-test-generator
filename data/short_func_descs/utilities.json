{
  "example": "#include \"catch.hpp\"\n\n#include \"utils.h\"\n#include \"basics.h\"\n#include \"random.h\"\n#include <chrono>\n\nusing namespace splashkit_lib;\n\nTEST_CASE(\"substring contained within string is detected\", \"[contains]\")\n{\n    SECTION(\"substring is at the start of the string\")\n    {\n        REQUIRE(contains(\"splashkit library\", \"splashkit\"));\n    }\n    SECTION(\"substring is at the end of the string\")\n    {\n        REQUIRE(contains(\"splashkit library\", \"library\"));\n    }\n    SECTION(\"substring is in the middle of the string\")\n    {\n        REQUIRE(contains(\"splashkit library\", \"it lib\"));\n    }\n    SECTION(\"substring is empty\")\n    {\n        REQUIRE(contains(\"splashkit library\", \"\"));\n    }\n    SECTION(\"substring is the same as the string\")\n    {\n        REQUIRE(contains(\"splashkit library\", \"splashkit library\"));\n    }\n    SECTION(\"both string and substring are empty\")\n    {\n        REQUIRE(contains(\"\", \"\"));\n    }\n    SECTION(\"substring is not in the string\")\n    {\n        REQUIRE_FALSE(contains(\"splashkit library\", \"unreal\"));\n    }\n    SECTION(\"substring is larger than the string\")\n    {\n        REQUIRE_FALSE(contains(\"splashkit library\", \"splashkit library is the best\"));\n    }\n    SECTION(\"string is empty\")\n    {\n        REQUIRE_FALSE(contains(\"\", \"splashkit\"));\n    }\n}\nTEST_CASE(\"string is converted to double\", \"[covert_to_double]\")\n{\n    SECTION(\"string is an integer\")\n    {\n        REQUIRE(convert_to_double(\"123\") == 123.0);\n    }\n    SECTION(\"string is a decimal number\")\n    {\n        REQUIRE(convert_to_double(\"123.456\") == 123.456);\n    }\n    SECTION(\"string is a negative integer\")\n    {\n        REQUIRE(convert_to_double(\"-123\") == -123.0);\n    }\n    SECTION(\"string is a negative decimal number\")\n    {\n        REQUIRE(convert_to_double(\"-123.456\") == -123.456);\n    }\n    SECTION(\"string is a decimal number with no integer part\")\n    {\n        REQUIRE(convert_to_double(\".456\") == 0.456);\n    }\n    SECTION(\"string is a decimal number with no decimal part\")\n    {\n        REQUIRE(convert_to_double(\"123.\") == 123.0);\n    }\n    SECTION (\"string is a decimal number with multiple zeroes before the decimal point\")\n    {\n        REQUIRE(convert_to_double(\"000123.456\") == 123.456);\n    }\n    SECTION (\"string is a decimal number with multiple zeroes after the decimal point\")\n    {\n        REQUIRE(convert_to_double(\"123.456000\") == 123.456);\n    }\n    SECTION(\"string is a decimal number with multiple zeroes before and after the decimal point\")\n    {\n        REQUIRE(convert_to_double(\"000123.456000\") == 123.456);\n    }\n    SECTION(\"string is a decimal number with multiple zeroes before the decimal point and no decimal part\")\n    {\n        REQUIRE(convert_to_double(\"000123.\") == 123.0);\n    }\n    SECTION(\"string is a decimal number with no integer part and multiple zeroes after the decimal point\")\n    {\n        REQUIRE(convert_to_double(\".456000\") == 0.456);\n    }\n    SECTION(\"string has leading whitespace\")\n    {\n        REQUIRE(convert_to_double(\" 123\") == 123.0);\n    }\n    SECTION(\"string has trailing whitespace\")\n    {\n        REQUIRE(convert_to_double(\"123 \") == 123.0);\n    }\n    SECTION(\"string has leading and trailing whitespace\")\n    {\n        REQUIRE(convert_to_double(\" 123 \") == 123.0);\n    }\n    SECTION(\"string is a negative decimal number with leading whitespace\")\n    {\n        REQUIRE(convert_to_double(\" -123.456\") == -123.456);\n    }\n    SECTION(\"string is a negative decimal number with trailing whitespace\")\n    {\n        REQUIRE(convert_to_double(\"-123.456 \") == -123.456);\n    }\n    SECTION(\"string is a negative decimal number with leading and trailing whitespace\")\n    {\n        REQUIRE(convert_to_double(\" -123.456 \") == -123.456);\n    }\n    SECTION(\"string has multiple decimal points\")\n    {\n        REQUIRE(convert_to_double(\"123.456.789\") == 123.456);\n    }\n    SECTION(\"string is infinite\")\n    {\n        REQUIRE(convert_to_double(\"inf\") == INFINITY);\n    }\n    SECTION(\"string is negative infinite\")\n    {\n        REQUIRE(convert_to_double(\"-inf\") == -INFINITY);\n    }\n    SECTION(\"string is scientific notation\")\n    {\n        REQUIRE(convert_to_double(\"1.23e2\") == 123.0);\n    }\n    SECTION(\"string is negative scientific notation\")\n    {\n        REQUIRE(convert_to_double(\"-1.23e2\") == -123.0);\n    }\n    SECTION(\"string is a decimal number with no integer or decimal part\")\n    {\n        REQUIRE_THROWS(convert_to_double(\".\"));\n    }\n    SECTION(\"string is not a number\")\n    {\n        REQUIRE_THROWS(convert_to_double(\"SplashKit\"));\n    }\n    SECTION(\"string is empty\")\n    {\n        REQUIRE_THROWS(convert_to_double(\"\"));\n    }\n}\nTEST_CASE(\"string is converted to integer\", \"[covert_to_integer]\")\n{\n    SECTION(\"string is an integer\")\n    {\n        REQUIRE(convert_to_integer(\"123\") == 123);\n    }\n    SECTION(\"string is a decimal number\")\n    {\n        REQUIRE(convert_to_integer(\"123.456\") == 123);\n    }\n    SECTION(\"string is a negative integer\")\n    {\n        REQUIRE(convert_to_integer(\"-123\") == -123);\n    }\n    SECTION(\"string is a negative decimal number\")\n    {\n        REQUIRE(convert_to_integer(\"-123.456\") == -123);\n    }\n    SECTION(\"string is a decimal number with no decimal part\")\n    {\n        REQUIRE(convert_to_integer(\"123.\") == 123);\n    }\n    SECTION (\"string is a decimal number with multiple zeroes before the decimal point\")\n    {\n        REQUIRE(convert_to_integer(\"000123.456\") == 123);\n    }\n    SECTION (\"string is a decimal number with multiple zeroes after the decimal point\")\n    {\n        REQUIRE(convert_to_integer(\"123.456000\") == 123);\n    }\n    SECTION(\"string is a decimal number with multiple zeroes before and after the decimal point\")\n    {\n        REQUIRE(convert_to_integer(\"000123.456000\") == 123);\n    }\n    SECTION(\"string is a decimal number with multiple zeroes before the decimal point and no decimal part\")\n    {\n        REQUIRE(convert_to_integer(\"000123.\") == 123);\n    }\n    SECTION(\"string has leading whitespace\")\n    {\n        REQUIRE(convert_to_integer(\" 123\") == 123);\n    }\n    SECTION(\"string has trailing whitespace\")\n    {\n        REQUIRE(convert_to_integer(\"123 \") == 123);\n    }\n    SECTION(\"string has leading and trailing whitespace\")\n    {\n        REQUIRE(convert_to_integer(\" 123 \") == 123);\n    }\n    SECTION(\"string is a negative decimal number with leading whitespace\")\n    {\n        REQUIRE(convert_to_integer(\" -123.456\") == -123);\n    }\n    SECTION(\"string is a negative decimal number with trailing whitespace\")\n    {\n        REQUIRE(convert_to_integer(\"-123.456 \") == -123);\n    }\n    SECTION(\"string is a negative decimal number with leading and trailing whitespace\")\n    {\n        REQUIRE(convert_to_integer(\" -123.456 \") == -123);\n    }\n    SECTION(\"string has multiple decimal points\")\n    {\n        REQUIRE(convert_to_integer(\"123.456.789\") == 123);\n    }\n    SECTION(\"string is a decimal number with no integer part and multiple zeroes after the decimal point\")\n    {\n        REQUIRE_THROWS(convert_to_integer(\".456000\"));\n    }\n    SECTION(\"string is a decimal number with no integer part\")\n    {\n        REQUIRE_THROWS(convert_to_integer(\".456\"));\n    }\n    SECTION(\"string is a decimal number with no integer or decimal part\")\n    {\n        REQUIRE_THROWS(convert_to_integer(\".\"));\n    }\n    SECTION(\"string is not a number\")\n    {\n        REQUIRE_THROWS(convert_to_integer(\"SplashKit\"));\n    }\n    SECTION(\"string is empty\")\n    {\n        REQUIRE_THROWS(convert_to_integer(\"\"));\n    }\n}\nTEST_CASE(\"substring's index is found in the string\", \"[index_of]\")\n{\n    SECTION(\"substring is at the start of the string\")\n    {\n        REQUIRE(index_of(\"splashkit library\", \"splashkit\") == 0);\n    }\n    SECTION(\"substring is at the end of the string\")\n    {\n        REQUIRE(index_of(\"splashkit library\", \"library\") == 10);\n    }\n    SECTION(\"substring is in the middle of the string\")\n    {\n        REQUIRE(index_of(\"splashkit library\", \"it lib\") == 7);\n    }\n    SECTION(\"substring is not in the string\")\n    {\n        REQUIRE(index_of(\"splashkit library\", \"unreal\") == -1);\n    }\n    SECTION(\"substring is the same as the string\")\n    {\n        REQUIRE(index_of(\"splashkit library\", \"splashkit library\") == 0);\n    }\n    SECTION(\"substring is larger than the string\")\n    {\n        REQUIRE(index_of(\"splashkit library\", \"splashkit library is the best\") == -1);\n    }\n    SECTION(\"substring is empty\")\n    {\n        REQUIRE(index_of(\"splashkit library\", \"\") == 0);\n    }\n    SECTION(\"string is empty\")\n    {\n        REQUIRE(index_of(\"\", \"splashkit\") == -1);\n    }\n    SECTION(\"both string and substring are empty\")\n    {\n        REQUIRE(index_of(\"\", \"\") == 0);\n    }\n}\nTEST_CASE(\"verify that string is double\", \"[is_double]\")\n{\n    SECTION(\"string is a decimal number\")\n    {\n        REQUIRE(is_double(\"123.456\"));\n    }\n    SECTION(\"string is an integer\")\n    {\n        REQUIRE(is_double(\"123\"));\n    }\n    SECTION(\"string is a negative decimal number\")\n    {\n        REQUIRE(is_double(\"-123.456\"));\n    }\n    SECTION(\"string is a negative integer\")\n    {\n        REQUIRE(is_double(\"-123\"));\n    }\n    SECTION(\"string is a decimal number with no decimal part\")\n    {\n        REQUIRE(is_double(\"123.\"));\n    }\n    SECTION(\"string is a decimal number with multiple zeroes before the decimal point\")\n    {\n        REQUIRE(is_double(\"000123.456\"));\n    }\n    SECTION(\"string is a decimal number with multiple zeroes after the decimal point\")\n    {\n        REQUIRE(is_double(\"123.456000\"));\n    }\n    SECTION(\"string is a decimal number with multiple zeroes before and after the decimal point\")\n    {\n        REQUIRE(is_double(\"000123.456000\"));\n    }\n    SECTION(\"string is a decimal number with multiple zeroes before the decimal point and no decimal part\")\n    {\n        REQUIRE(is_double(\"000123.\"));\n    }\n    SECTION(\"string is a decimal number with no integer part\")\n    {\n        REQUIRE_FALSE(is_double(\".456\"));\n    }\n    SECTION(\"string is a decimal number with no integer or decimal part\")\n    {\n        REQUIRE_FALSE(is_double(\".\"));\n    }\n    SECTION(\"string is not a number\")\n    {\n        REQUIRE_FALSE(is_double(\"SplashKit\"));\n    }\n    SECTION(\"string is empty\")\n    {\n        REQUIRE_FALSE(is_double(\"\"));\n    }\n}\nTEST_CASE(\"verify that string is integer\", \"[is_integer]\")\n{\n    SECTION(\"string is an integer\")\n    {\n        REQUIRE(is_integer(\"123\"));\n    }\n    SECTION(\"string is a negative integer\")\n    {\n        REQUIRE(is_integer(\"-123\"));\n    }\n    SECTION(\"string is a decimal number\")\n    {\n        REQUIRE_FALSE(is_integer(\"123.456\"));\n    }\n    SECTION(\"string is a negative decimal number\")\n    {\n        REQUIRE_FALSE(is_integer(\"-123.456\"));\n    }\n    SECTION(\"string is a decimal number with no decimal part\")\n    {\n        REQUIRE_FALSE(is_integer(\"123.\"));\n    }\n    SECTION(\"string is a decimal number with multiple zeroes before the decimal point\")\n    {\n        REQUIRE_FALSE(is_integer(\"000123.456\"));\n    }\n    SECTION(\"string is a decimal number with multiple zeroes after the decimal point\")\n    {\n        REQUIRE_FALSE(is_integer(\"123.456000\"));\n    }\n    SECTION(\"string is a decimal number with multiple zeroes before and after the decimal point\")\n    {\n        REQUIRE_FALSE(is_integer(\"000123.456000\"));\n    }\n    SECTION(\"string is a double with multiple zeroes before the decimal point and no decimal part\")\n    {\n        REQUIRE_FALSE(is_integer(\"000123.\"));\n    }\n    SECTION(\"string is a double with no integer part and multiple zeroes after the decimal point\")\n    {\n        REQUIRE_FALSE(is_integer(\".456000\"));\n    }\n    SECTION(\"string is a double with no integer part\")\n    {\n        REQUIRE_FALSE(is_integer(\".456\"));\n    }\n    SECTION(\"string is a double with no integer or decimal part\")\n    {\n        REQUIRE_FALSE(is_integer(\".\"));\n    }\n    SECTION(\"string is not a number\")\n    {\n        REQUIRE_FALSE(is_integer(\"SplashKit\"));\n    }\n    SECTION(\"string is empty\")\n    {\n        REQUIRE_FALSE(is_integer(\"\"));\n    }\n}\nTEST_CASE(\"verify that string is number\", \"[is_number]\")\n{\n    SECTION(\"string is a double\")\n    {\n        REQUIRE(is_number(\"123.456\"));\n    }\n    SECTION(\"string is an integer\")\n    {\n        REQUIRE(is_number(\"123\"));\n    }\n    SECTION(\"string is a negative double\")\n    {\n        REQUIRE(is_number(\"-123.456\"));\n    }\n    SECTION(\"string is a negative integer\")\n    {\n        REQUIRE(is_number(\"-123\"));\n    }\n    SECTION(\"string is a double with no integer part\")\n    {\n        REQUIRE_FALSE(is_number(\".456\"));\n    }\n    SECTION(\"string is a double with no decimal part\")\n    {\n        REQUIRE(is_number(\"123.\"));\n    }\n    SECTION(\"string is a double with multiple zeroes before the decimal point\")\n    {\n        REQUIRE(is_number(\"000123.456\"));\n    }\n    SECTION(\"string is a double with multiple zeroes after the decimal point\")\n    {\n        REQUIRE(is_number(\"123.456000\"));\n    }\n    SECTION(\"string is a double with multiple zeroes before and after the decimal point\")\n    {\n        REQUIRE(is_number(\"000123.456000\"));\n    }\n    SECTION(\"string is a double with multiple zeroes before the decimal point and no decimal part\")\n    {\n        REQUIRE(is_number(\"000123.\"));\n    }\n    SECTION(\"string is a double with no integer part and multiple zeroes after the decimal point\")\n    {\n        REQUIRE_FALSE(is_number(\".456000\"));\n    }\n    SECTION(\"string is a double with no integer part\")\n    {\n        REQUIRE_FALSE(is_number(\".456\"));\n    }\n    SECTION(\"string is a double with no integer or decimal part\")\n    {\n        REQUIRE_FALSE(is_number(\".\"));\n    }\n    SECTION(\"string is not a number\")\n    {\n        REQUIRE_FALSE(is_number(\"SplashKit\"));\n    }\n    SECTION(\"string is empty\")\n    {\n        REQUIRE_FALSE(is_number(\"\"));\n    }\n}\nTEST_CASE(\"length of string is calculated\", \"[length_of]\")\n{\n    SECTION(\"string is not empty\")\n    {\n        REQUIRE(length_of(\"splashkit\") == 9);\n    }\n    SECTION(\"string is empty\")\n    {\n        REQUIRE(length_of(\"\") == 0);\n    }\n}\nTEST_CASE(\"replace all occurrences of a substring in a string with another string\", \"[replace_all]\")\n{\n    SECTION(\"substring is at the start of the string\")\n    {\n        REQUIRE(replace_all(\"splashkit library\", \"splashkit\", \"SK\") == \"SK library\");\n    }\n    SECTION(\"substring is at the end of the string\")\n    {\n        REQUIRE(replace_all(\"splashkit library\", \"library\", \"lib\") == \"splashkit lib\");\n    }\n    SECTION(\"substring is in the middle of the string\")\n    {\n        REQUIRE(replace_all(\"splashkit library\", \"it lib\", \"itlib\") == \"splashkitlibrary\");\n    }\n    SECTION(\"substring is not in the string\")\n    {\n        REQUIRE(replace_all(\"splashkit library\", \"unreal\", \"tournament\") == \"splashkit library\");\n    }\n    SECTION(\"substring is the same as the string\")\n    {\n        REQUIRE(replace_all(\"splashkit library\", \"splashkit library\", \"SK\") == \"SK\");\n    }\n    SECTION(\"substring is larger than the string\")\n    {\n        REQUIRE(replace_all(\"splashkit library\", \"splashkit library is the best\", \"SK\") == \"splashkit library\");\n    }\n    SECTION(\"string is empty\")\n    {\n        REQUIRE(replace_all(\"\", \"splashkit\", \"SK\") == \"\");\n    }\n    SECTION(\"replacement is empty\")\n    {\n        REQUIRE(replace_all(\"splashkit library\", \"splashkit\", \"\") == \" library\");\n    }\n    SECTION(\"substring is empty\")\n    {\n        REQUIRE(replace_all(\"splashkit library\", \"\", \"SK\") == \"splashkit library\");\n    }\n    SECTION(\"both string and substring are empty\")\n    {\n        REQUIRE(replace_all(\"\", \"\", \"SK\") == \"\");\n    }\n}\nTEST_CASE(\"can split a string into an array of strings based on a delimiter\")\n{\n    SECTION(\"string is not empty\")\n    {\n        vector<string> result = split(\"splashkit library\", ' ');\n        vector<string> expected = { \"splashkit\", \"library\" };\n        REQUIRE(result == expected);\n    }\n    SECTION(\"string is empty\")\n    {\n        vector<string> result = split(\"\", ' ');\n        vector<string> expected = { \"\" };\n        REQUIRE(result == expected);\n    }\n    SECTION(\"delimiter is not in the string\")\n    {\n        vector<string> result = split(\"splashkit library\", ',');\n        vector<string> expected = { \"splashkit library\" };\n        REQUIRE(result == expected);\n    }\n    SECTION(\"delimiter is at the start of the string\")\n    {\n        vector<string> result = split(\",splashkit library\", ',');\n        vector<string> expected = { \"\", \"splashkit library\" };\n        REQUIRE(result == expected);\n    }\n    SECTION(\"delimiter is at the end of the string\")\n    {\n        vector<string> result = split(\"splashkit library,\", ',');\n        vector<string> expected = { \"splashkit library\", \"\" };\n        REQUIRE(result == expected);\n    }\n    SECTION(\"delimiter is at the start and end of the string\")\n    {\n        vector<string> result = split(\",splashkit library,\", ',');\n        vector<string> expected = { \"\", \"splashkit library\", \"\" };\n        REQUIRE(result == expected);\n    }\n    SECTION(\"delimiter is repeated\")\n    {\n        vector<string> result = split(\"splashkit,,library\", ',');\n        vector<string> expected = { \"splashkit\", \"\", \"library\" };\n        REQUIRE(result == expected);\n    }\n    SECTION(\"delimiter is a space\")\n    {\n        vector<string> result = split(\"splashkit library\", ' ');\n        vector<string> expected = { \"splashkit\", \"library\" };\n        REQUIRE(result == expected);\n    }\n    SECTION(\"delimiter is a tab\")\n    {\n        vector<string> result = split(\"splashkit\\tlibrary\", '\\t');\n        vector<string> expected = { \"splashkit\", \"library\" };\n        REQUIRE(result == expected);\n    }\n    SECTION(\"delimiter is a newline\")\n    {\n        vector<string> result = split(\"splashkit\\nlibrary\", '\\n');\n        vector<string> expected = { \"splashkit\", \"library\" };\n        REQUIRE(result == expected);\n    }\n    SECTION(\"delimiter is a carriage return\")\n    {\n        vector<string> result = split(\"splashkit\\rlibrary\", '\\r');\n        vector<string> expected = { \"splashkit\", \"library\" };\n        REQUIRE(result == expected);\n    }\n    SECTION(\"delimiter is a space, newline, and carriage return\")\n    {\n        vector<string> result = split(\"splashkit \\n\\rlibrary\", ' ');\n        vector<string> expected = { \"splashkit\", \"\\n\\rlibrary\" };\n        REQUIRE(result == expected);\n    }\n}\nTEST_CASE(\"string is converted to lowercase\", \"[to_lowercase]\")\n{\n    SECTION(\"string is not empty\")\n    {\n        REQUIRE(to_lowercase(\"SPLASHKIT\") == \"splashkit\");\n    }\n    SECTION(\"string is empty\")\n    {\n        REQUIRE(to_lowercase(\"\") == \"\");\n    }\n    SECTION(\"string is already lowercase\")\n    {\n        REQUIRE(to_lowercase(\"splashkit\") == \"splashkit\");\n    }\n    SECTION(\"string is mixed case\")\n    {\n        REQUIRE(to_lowercase(\"SpLaShKiT\") == \"splashkit\");\n    }\n}\nTEST_CASE(\"string is converted to uppercase\", \"[to_uppercase]\")\n{\n    SECTION(\"string is not empty\")\n    {\n        REQUIRE(to_uppercase(\"splashkit\") == \"SPLASHKIT\");\n    }\n    SECTION(\"string is empty\")\n    {\n        REQUIRE(to_uppercase(\"\") == \"\");\n    }\n    SECTION(\"string is already uppercase\")\n    {\n        REQUIRE(to_uppercase(\"SPLASHKIT\") == \"SPLASHKIT\");\n    }\n    SECTION(\"string is mixed case\")\n    {\n        REQUIRE(to_uppercase(\"SpLaShKiT\") == \"SPLASHKIT\");\n    }\n}\nTEST_CASE(\"string is trimmed\", \"[trim]\")\n{\n    SECTION(\"string is empty\")\n    {\n        REQUIRE(trim(\"\") == \"\");\n    }\n    SECTION(\"string has leading whitespace\")\n    {\n        REQUIRE(trim(\"  splashkit\") == \"splashkit\");\n    }\n    SECTION(\"string has trailing whitespace\")\n    {\n        REQUIRE(trim(\"splashkit  \") == \"splashkit\");\n    }\n    SECTION(\"string has leading and trailing whitespace\")\n    {\n        REQUIRE(trim(\"  splashkit  \") == \"splashkit\");\n    }\n    SECTION(\"string has no leading or trailing whitespace\")\n    {\n        REQUIRE(trim(\"splashkit\") == \"splashkit\");\n    }\n}\nTEST_CASE(\"random number float between 0 and 1 is generated\", \"[rnd]\")\n{\n    float result = rnd();\n    REQUIRE(result >= 0);\n    REQUIRE(result <= 1);\n}\nTEST_CASE(\"random number int between 0 and ubound is generated\", \"[rnd(int ubound)]\")\n{\n    SECTION(\"ubound is 1\")\n    {\n        int result = rnd(1);\n        REQUIRE(result >= 0);\n        REQUIRE(result <= 1);\n    }\n    SECTION(\"ubound is 10\")\n    {\n        int result = rnd(10);\n        REQUIRE(result >= 0);\n        REQUIRE(result <= 10);\n    }\n    SECTION(\"ubound is -1\")\n    {\n        int result = rnd(-1);\n        REQUIRE(result == 0);\n    }\n    SECTION(\"ubound is 0\")\n    {\n        int result = rnd(0);\n        REQUIRE(result == 0);\n    }\n}\nTEST_CASE(\"random number int between min and max is generated\", \"[rnd(int min, int max)]\")\n{\n    SECTION(\"min is 0 and max is 1\")\n    {\n        int result = rnd(0, 1);\n        REQUIRE(result >= 0);\n        REQUIRE(result <= 1);\n    }\n    SECTION(\"min is 0 and max is 10\")\n    {\n        int result = rnd(0, 10);\n        REQUIRE(result >= 0);\n        REQUIRE(result <= 10);\n    }\n    SECTION(\"min is -1 and max is 1\")\n    {\n        int result = rnd(-1, 1);\n        REQUIRE(result >= -1);\n        REQUIRE(result <= 1);\n    }\n    SECTION(\"min is 1 and max is 0\")\n    {\n        int result = rnd(1, 0);\n        REQUIRE(result >= 0);\n        REQUIRE(result <= 1);\n    }\n    SECTION(\"min is 1 and max is 1\")\n    {\n        int result = rnd(1, 1);\n        REQUIRE(result == 1);\n    }\n}\nTEST_CASE(\"gets the number of milliseconds that have passed since the program was started\", \"[current_ticks]\")\n{\n    unsigned int result = current_ticks();\n    REQUIRE(result >= 0);\n}\nTEST_CASE(\"program is put to sleep for a specified number of milliseconds\", \"[delay]\")\n{\n    constexpr long long DELAY_THRESHOLD = 80;\n    \n    SECTION(\"milliseconds is 0\")\n    {\n        auto start = std::chrono::steady_clock::now();\n        delay(0);\n        auto end = std::chrono::steady_clock::now();\n        REQUIRE(std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() < DELAY_THRESHOLD);\n    }\n    SECTION(\"milliseconds is 200\")\n    {\n        constexpr int DELAY = 200;\n        auto start = std::chrono::steady_clock::now();\n        delay(DELAY);\n        auto end = std::chrono::steady_clock::now();\n        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();\n        REQUIRE(duration >= (DELAY - DELAY_THRESHOLD));\n        #if defined(__APPLE__) || defined(__MACH__)\n            // found to be unreliable during macOS CI tests, so for now we don't enforce it\n            // perhaps it can be made more reliable later\n            CHECK_NOFAIL(duration <= (DELAY + DELAY_THRESHOLD));\n            INFO(\"[SKIPPING TEST] Delay known to take longer than needed during macOS CI\");\n        #else\n            REQUIRE(duration <= (DELAY + DELAY_THRESHOLD));\n        #endif\n    }\n}\nTEST_CASE(\"return a SplashKit resource of resource_kind with name filename as a string\", \"[file_as_string]\")\n{\n    const resource_kind RESOURCE = resource_kind::BUNDLE_RESOURCE;\n    const string RESOURCE_PATH = \"blah.txt\";\n    \n    SECTION(\"filename is a valid file\")\n    {\n        string result = file_as_string(RESOURCE_PATH, RESOURCE);\n        string expected = \"BITMAP,ufo,ufo.png\\n\";\n        REQUIRE(result == expected);\n    }\n    SECTION(\"filename is an empty string\")\n    {\n        string result = file_as_string(\"\", RESOURCE);\n        string expected = \"\";\n        REQUIRE(result == expected);\n    }\n    SECTION(\"filename is an invalid file\")\n    {\n        string result = file_as_string(\"invalid.txt\", RESOURCE);\n        string expected = \"\";\n        REQUIRE(result == expected);\n    }\n}",
  "tests": [
    {
      "description": "Returns true if the string contains the substring.",
      "name": "contains",
      "return_description": "True if the substring is found in the text.",
      "signature": "bool contains(const string &text,const string &subtext);",
      "unique_global_name": "contains"
    },
    {
      "description": "Convert the passed in string into a double. This can fail in an error if\nthe value is not a number, consider using `is_number` to check before\nconverting a string.",
      "name": "convert_to_double",
      "return_description": "The double value read from the text.",
      "signature": "double convert_to_double(const string &text);",
      "unique_global_name": "convert_to_double"
    },
    {
      "description": "Convert the passed in string into an integer. This can fail in an error if\nthe value is not an integer, consider using `is_integer` to check before\nconverting a string.",
      "name": "convert_to_integer",
      "return_description": "The integer value read from the text.",
      "signature": "int convert_to_integer(const string &text);",
      "unique_global_name": "convert_to_integer"
    },
    {
      "description": "Returns the index of the first occurrence of the substring in the text.",
      "name": "index_of",
      "return_description": "The index of the first occurrence of the substring in the text, or -1 if the substring is not found.",
      "signature": "int index_of(const string &text,const string &subtext);",
      "unique_global_name": "index_of"
    },
    {
      "description": "Checks if a string contains a number.",
      "name": "is_double",
      "return_description": "True if the text contains a number (and only a number).",
      "signature": "bool is_double(const string &text);",
      "unique_global_name": "is_double"
    },
    {
      "description": "Checks if a string contains an integer value.",
      "name": "is_integer",
      "return_description": "True if the text contains a whole number (and only a whole\nnumber).",
      "signature": "bool is_integer(const string &text);",
      "unique_global_name": "is_integer"
    },
    {
      "description": "Checks if a string contains a number.",
      "name": "is_number",
      "return_description": "True if the text contains a number (and only a number).",
      "signature": "bool is_number(const string &text);",
      "unique_global_name": "is_number"
    },
    {
      "description": "Returns the length of a string in characters.",
      "name": "length_of",
      "return_description": "The number of characters in the string.",
      "signature": "int length_of(const string &text);",
      "unique_global_name": "length_of"
    },
    {
      "description": "Replace all occurrences of a substring in a string with another string.",
      "name": "replace_all",
      "return_description": "The text with all occurrences of the substring replaced with the new text.",
      "signature": "string replace_all(const string &text,const string &substr,const string &newText);",
      "unique_global_name": "replace_all"
    },
    {
      "description": "Split a string into an array of strings based on a delimiter.",
      "name": "split",
      "return_description": "An array of strings",
      "signature": "vector<string> split(const string &text,char delimiter);",
      "unique_global_name": "split"
    },
    {
      "description": "Return a lowercase version of the passed in string.",
      "name": "to_lowercase",
      "return_description": "A lower case version of the passed in text.",
      "signature": "string to_lowercase(const string &text);",
      "unique_global_name": "to_lowercase"
    },
    {
      "description": "Return a UPPERCASE version of the passed in string.",
      "name": "to_uppercase",
      "return_description": "An upper case version of the passed in text.",
      "signature": "string to_uppercase(const string &text);",
      "unique_global_name": "to_uppercase"
    },
    {
      "description": "Return a new string that removes the spaces from the start and end of\nthe input string.",
      "name": "trim",
      "return_description": "A new string with the contents of `text`, after removing spaces\nfrom the start and end.",
      "signature": "string trim(const string &text);",
      "unique_global_name": "trim"
    },
    {
      "description": "Generates a random number between 'min' and `max`, including 'min' and 'max'.",
      "name": "rnd",
      "return_description": "Returns an `int` between and including `min` and `max`",
      "signature": "int rnd(int min,int max);",
      "unique_global_name": "rnd_range"
    },
    {
      "description": "Generates a random number between 0 and 1",
      "name": "rnd",
      "return_description": "Returns a `float` between `0` and `1`",
      "signature": "float rnd();",
      "unique_global_name": "rnd"
    },
    {
      "description": "Generates a random number between 0 and `ubound`.",
      "name": "rnd",
      "return_description": "Returns an `int` between `0` and `ubound`",
      "signature": "int rnd(int ubound);",
      "unique_global_name": "rnd_int"
    },
    {
      "description": "Gets the number of milliseconds that have passed since the program was\nstarted.",
      "name": "current_ticks",
      "return_description": "The number of milliseconds passed",
      "signature": "unsigned int current_ticks();",
      "unique_global_name": "current_ticks"
    },
    {
      "description": "Puts the program to sleep for a specified number of milliseconds. If this\nis larger than 1 second, SplashKit will check to see if the user tries to\nquit during the delay. If the user does quit, the delay function returns\nwithout waiting.",
      "name": "delay",
      "return_description": null,
      "signature": "void delay(int milliseconds);",
      "unique_global_name": "delay"
    },
    {
      "description": "Display a dialog to the screen with a message for the user.",
      "name": "display_dialog",
      "return_description": null,
      "signature": "void display_dialog(const string &title,const string &msg,font output_font,int font_size);",
      "unique_global_name": "display_dialog"
    },
    {
      "description": "Return a SplashKit resource of `resource_kind` with name `filename`\nas a string.",
      "name": "file_as_string",
      "return_description": "The file loaded into a string.",
      "signature": "string file_as_string(string filename,resource_kind kind);",
      "unique_global_name": "file_as_string"
    }
  ]
}
